"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// ../node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../node_modules/base64-js/index.js"(exports) {
    "use strict";
    init_polyfill();
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../node_modules/ieee754/index.js"(exports) {
    init_polyfill();
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    init_polyfill();
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24);
      const hi = this[++offset] + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + last * __pow(2, 24);
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
      const lo = this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * __pow(2, 8) + this[offset + 6] * __pow(2, 16) + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24));
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range2, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > __pow(2, 32)) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > __pow(BigInt(2), BigInt(32)) || input < -__pow(BigInt(2), BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range2}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range2;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range2 = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range2 = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range2 = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// ../node_modules/process/browser.js
var require_browser = __commonJS({
  "../node_modules/process/browser.js"(exports, module2) {
    init_polyfill();
    var process2 = module2.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker2) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker2);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker2);
      }
      try {
        return cachedClearTimeout(marker2);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker2);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker2);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process2.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process2.title = "browser";
    process2.browser = true;
    process2.env = {};
    process2.argv = [];
    process2.version = "";
    process2.versions = {};
    function noop() {
    }
    process2.on = noop;
    process2.addListener = noop;
    process2.once = noop;
    process2.off = noop;
    process2.removeListener = noop;
    process2.removeAllListeners = noop;
    process2.emit = noop;
    process2.prependListener = noop;
    process2.prependOnceListener = noop;
    process2.listeners = function(name) {
      return [];
    };
    process2.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process2.cwd = function() {
      return "/";
    };
    process2.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process2.umask = function() {
      return 0;
    };
  }
});

// polyfill.mjs
var import_buffer, process_browser2;
var init_polyfill = __esm({
  "polyfill.mjs"() {
    "use strict";
    import_buffer = __toESM(require_buffer(), 1);
    process_browser2 = __toESM(require_browser(), 1);
    window.Buffer = import_buffer.Buffer;
    window.process_browser = process_browser2;
  }
});

// ../node_modules/events/events.js
var require_events = __commonJS({
  "../node_modules/events/events.js"(exports, module2) {
    "use strict";
    init_polyfill();
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module2.exports = EventEmitter;
    module2.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// ../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../node_modules/inherits/inherits_browser.js"(exports, module2) {
    init_polyfill();
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module2) {
    init_polyfill();
    module2.exports = require_events().EventEmitter;
  }
});

// ../node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "../node_modules/buffer/index.js"(exports) {
    "use strict";
    init_polyfill();
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        var proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      var valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      var b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(
          value[Symbol.toPrimitive]("string"),
          encodingOrOffset,
          length
        );
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);
      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      var buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer3.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer3.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      var alphabet = "0123456789abcdef";
      var table = new Array(256);
      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
  }
});

// (disabled):util
var require_util = __commonJS({
  "(disabled):util"() {
    init_polyfill();
  }
});

// ../node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module2) {
    "use strict";
    init_polyfill();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require = require_buffer2();
    var Buffer3 = _require.Buffer;
    var _require2 = require_util();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer3.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next)
            ret += s + p.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer3.alloc(0);
          var ret = Buffer3.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer3.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    init_polyfill();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process_browser.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process_browser.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process_browser.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process_browser.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process_browser.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process_browser.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process_browser.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "../node_modules/readable-stream/errors-browser.js"(exports, module2) {
    "use strict";
    init_polyfill();
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name, " argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name, ".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/state.js"(exports, module2) {
    "use strict";
    init_polyfill();
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../node_modules/util-deprecate/browser.js
var require_browser2 = __commonJS({
  "../node_modules/util-deprecate/browser.js"(exports, module2) {
    init_polyfill();
    module2.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!window.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = window.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// ../node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
    "use strict";
    init_polyfill();
    module2.exports = Writable6;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex2;
    Writable6.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream2 = require_stream_browser();
    var Buffer3 = require_buffer2().Buffer;
    var OurUint8Array = (typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable6, Stream2);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable6, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable6)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable6(options) {
      Duplex2 = Duplex2 || require_stream_duplex();
      var isDuplex = this instanceof Duplex2;
      if (!isDuplex && !realHasInstance.call(Writable6, this))
        return new Writable6(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable6.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process_browser.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process_browser.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable6.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer3.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable6.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable6.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable6.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable6.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer3.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable6.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process_browser.nextTick(cb, er);
        process_browser.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process_browser.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable6.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable6.prototype._writev = null;
    Writable6.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable6.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process_browser.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process_browser.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable6.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable6.prototype.destroy = destroyImpl.destroy;
    Writable6.prototype._undestroy = destroyImpl.undestroy;
    Writable6.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
    "use strict";
    init_polyfill();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex2;
    var Readable8 = require_stream_readable();
    var Writable6 = require_stream_writable();
    require_inherits_browser()(Duplex2, Readable8);
    {
      keys = objectKeys(Writable6.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex2.prototype[method])
          Duplex2.prototype[method] = Writable6.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex2(options) {
      if (!(this instanceof Duplex2))
        return new Duplex2(options);
      Readable8.call(this, options);
      Writable6.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process_browser.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../node_modules/safe-buffer/index.js"(exports, module2) {
    init_polyfill();
    var buffer = require_buffer2();
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    init_polyfill();
    var Buffer3 = require_safe_buffer().Buffer;
    var isEncoding = Buffer3.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer3.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module2) {
    "use strict";
    init_polyfill();
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports, module2) {
    "use strict";
    init_polyfill();
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve = iter[kLastResolve];
      if (resolve !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process_browser.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve, reject) {
            process_browser.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports, module2) {
    init_polyfill();
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// ../node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
    "use strict";
    init_polyfill();
    module2.exports = Readable8;
    var Duplex2;
    Readable8.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream2 = require_stream_browser();
    var Buffer3 = require_buffer2().Buffer;
    var OurUint8Array = (typeof window !== "undefined" ? window : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug10;
    if (debugUtil && debugUtil.debuglog) {
      debug10 = debugUtil.debuglog("stream");
    } else {
      debug10 = function debug11() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable8, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable8(options) {
      Duplex2 = Duplex2 || require_stream_duplex();
      if (!(this instanceof Readable8))
        return new Readable8(options);
      var isDuplex = this instanceof Duplex2;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable8.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable8.prototype.destroy = destroyImpl.destroy;
    Readable8.prototype._undestroy = destroyImpl.undestroy;
    Readable8.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable8.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable8.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug10("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable8.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable8.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable8.prototype.read = function(n) {
      debug10("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug10("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug10("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug10("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug10("reading or ended", doRead);
      } else if (doRead) {
        debug10("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug10("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug10("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug10("emitReadable", state.flowing);
        state.emittedReadable = true;
        process_browser.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug10("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process_browser.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug10("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable8.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable8.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug10("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process_browser.stdout && dest !== process_browser.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process_browser.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug10("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug10("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug10("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug10("ondata");
        var ret = dest.write(chunk);
        debug10("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug10("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug10("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug10("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug10("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug10("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug10("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable8.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable8.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug10("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process_browser.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable8.prototype.addListener = Readable8.prototype.on;
    Readable8.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process_browser.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable8.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process_browser.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug10("readable nexttick read 0");
      self2.read(0);
    }
    Readable8.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug10("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process_browser.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug10("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable8.prototype.pause = function() {
      debug10("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug10("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug10("flow", state.flowing);
      while (state.flowing && stream.read() !== null)
        ;
    }
    Readable8.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug10("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug10("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug10("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable8.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable8.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable8.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable8.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable8._fromList = fromList;
    Object.defineProperty(Readable8.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug10("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process_browser.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug10("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable8.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable8, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
    "use strict";
    init_polyfill();
    module2.exports = Transform11;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex2 = require_stream_duplex();
    require_inherits_browser()(Transform11, Duplex2);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform11(options) {
      if (!(this instanceof Transform11))
        return new Transform11(options);
      Duplex2.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform11.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex2.prototype.push.call(this, chunk, encoding);
    };
    Transform11.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform11.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform11.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform11.prototype._destroy = function(err, cb) {
      Duplex2.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// ../node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module2) {
    "use strict";
    init_polyfill();
    module2.exports = PassThrough2;
    var Transform11 = require_stream_transform();
    require_inherits_browser()(PassThrough2, Transform11);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options);
      Transform11.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module2) {
    "use strict";
    init_polyfill();
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../node_modules/stream-browserify/index.js
var require_stream_browserify = __commonJS({
  "../node_modules/stream-browserify/index.js"(exports, module2) {
    init_polyfill();
    module2.exports = Stream2;
    var EE = require_events().EventEmitter;
    var inherits = require_inherits_browser();
    inherits(Stream2, EE);
    Stream2.Readable = require_stream_readable();
    Stream2.Writable = require_stream_writable();
    Stream2.Duplex = require_stream_duplex();
    Stream2.Transform = require_stream_transform();
    Stream2.PassThrough = require_stream_passthrough();
    Stream2.finished = require_end_of_stream();
    Stream2.pipeline = require_pipeline();
    Stream2.Stream = Stream2;
    function Stream2() {
      EE.call(this);
    }
    Stream2.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// src/index.browser.ts
var index_browser_exports4 = {};
__export(index_browser_exports4, {
  AACDepay: () => AACDepay,
  BasicDepay: () => BasicDepay,
  CanvasSink: () => CanvasSink,
  H264Depay: () => H264Depay,
  Html5CanvasPipeline: () => Html5CanvasPipeline,
  Html5VideoMetadataPipeline: () => Html5VideoMetadataPipeline,
  Html5VideoPipeline: () => Html5VideoPipeline,
  HttpMsePipeline: () => HttpMsePipeline,
  HttpSource: () => HttpSource,
  Inspector: () => Inspector,
  JPEGDepay: () => JPEGDepay,
  MessageType: () => MessageType,
  MetadataPipeline: () => MetadataPipeline,
  Mp4Capture: () => Mp4Capture,
  Mp4Muxer: () => Mp4Muxer,
  MseSink: () => MseSink,
  ONVIFDepay: () => ONVIFDepay,
  Pipeline: () => Pipeline,
  RTCPPacketType: () => RTCPPacketType,
  RTSPResponseError: () => RTSPResponseError,
  RTSP_METHOD: () => RTSP_METHOD,
  RtspMjpegPipeline: () => RtspMjpegPipeline,
  RtspMp4Pipeline: () => RtspMp4Pipeline,
  RtspParser: () => RtspParser,
  RtspPipeline: () => RtspPipeline,
  RtspSession: () => RtspSession,
  SDESItem: () => SDESItem,
  SR: () => SR,
  Scheduler: () => Scheduler,
  Sink: () => Sink,
  Source: () => Source,
  Tube: () => Tube,
  WSSource: () => WSSource,
  WsSdpPipeline: () => WsSdpPipeline,
  addRTSPRetry: () => addRTSPRetry,
  bodyOffset: () => bodyOffset,
  cSrc: () => cSrc,
  cSrcCount: () => cSrcCount,
  components: () => index_browser_exports,
  connectionEnded: () => connectionEnded,
  contentBase: () => contentBase,
  contentLocation: () => contentLocation,
  createTransform: () => createTransform,
  extHeader: () => extHeader,
  extHeaderLength: () => extHeaderLength,
  extension: () => extension,
  extractHeaderValue: () => extractHeaderValue,
  extractURIs: () => extractURIs,
  getTime: () => getTime,
  isRtcpApp: () => isRtcpApp,
  isRtcpBye: () => isRtcpBye,
  isRtcpRR: () => isRtcpRR,
  isRtcpSDES: () => isRtcpSDES,
  isRtcpSR: () => isRtcpSR,
  marker: () => marker,
  messageFromBuffer: () => messageFromBuffer,
  padding: () => padding,
  parse: () => parse2,
  parseRtcp: () => parseRtcp,
  payload: () => payload,
  payloadType: () => payloadType,
  pipelines: () => index_browser_exports2,
  range: () => range,
  rtcpMessageFromBuffer: () => rtcpMessageFromBuffer,
  sSrc: () => sSrc,
  sequence: () => sequence,
  sequenceNumber: () => sequenceNumber,
  sessionId: () => sessionId,
  sessionTimeout: () => sessionTimeout,
  statusCode: () => statusCode,
  timestamp: () => timestamp,
  utils: () => index_browser_exports3,
  version: () => version
});
module.exports = __toCommonJS(index_browser_exports4);
init_polyfill();

// src/components/index.browser.ts
var index_browser_exports = {};
__export(index_browser_exports, {
  AACDepay: () => AACDepay,
  BasicDepay: () => BasicDepay,
  CanvasSink: () => CanvasSink,
  H264Depay: () => H264Depay,
  HttpSource: () => HttpSource,
  Inspector: () => Inspector,
  JPEGDepay: () => JPEGDepay,
  MessageType: () => MessageType,
  Mp4Capture: () => Mp4Capture,
  Mp4Muxer: () => Mp4Muxer,
  MseSink: () => MseSink,
  ONVIFDepay: () => ONVIFDepay,
  RTSPResponseError: () => RTSPResponseError,
  RTSP_METHOD: () => RTSP_METHOD,
  RtspParser: () => RtspParser,
  RtspSession: () => RtspSession,
  Sink: () => Sink,
  Source: () => Source,
  Tube: () => Tube,
  WSSource: () => WSSource,
  createTransform: () => createTransform
});
init_polyfill();

// src/components/component.ts
init_polyfill();
var import_stream2 = __toESM(require_stream_browserify());

// src/components/helpers/stream-factory.ts
init_polyfill();
var import_stream = __toESM(require_stream_browserify());
var StreamFactory = class {
  /**
   * Creates a writable stream that sends all messages written to the stream
   * to a callback function and then considers it written.
   * @param fn  The callback to be invoked on the message
   */
  static consumer(fn = () => {
  }) {
    return new import_stream.Writable({
      objectMode: true,
      write(msg, _encoding, callback) {
        fn(msg);
        callback();
      }
    });
  }
  static peeker(fn) {
    if (typeof fn !== "function") {
      throw new Error("you must supply a function");
    }
    return new import_stream.Transform({
      objectMode: true,
      transform(msg, _encoding, callback) {
        fn(msg);
        callback(void 0, msg);
      }
    });
  }
  /**
   * Creates a readable stream that sends a message for each element of an array.
   * @param arr  The array with elements to be turned into a stream.
   */
  static producer(messages) {
    let counter = 0;
    return new import_stream.Readable({
      objectMode: true,
      read() {
        if (messages !== void 0) {
          if (counter < messages.length) {
            this.push(messages[counter++]);
          } else {
            this.push(null);
          }
        }
      }
    });
  }
  static recorder(type, fileStream) {
    return new import_stream.Transform({
      objectMode: true,
      transform(msg, encoding, callback) {
        const timestamp2 = Date.now();
        const message = Object.assign({}, msg, {
          data: msg.data.toString("base64")
        });
        fileStream.write(JSON.stringify({ type, timestamp: timestamp2, message }, null, 2));
        fileStream.write(",\n");
        callback(void 0, msg);
      }
    });
  }
  /**
   * Yield binary messages from JSON packet array until depleted.
   * @return {Generator} Returns a JSON packet iterator.
   */
  static replayer(packets) {
    let packetCounter = 0;
    let lastTimestamp = packets[0].timestamp;
    return new import_stream.Readable({
      objectMode: true,
      read() {
        const packet = packets[packetCounter++];
        if (packet) {
          const { type, timestamp: timestamp2, message } = packet;
          const delay = timestamp2 - lastTimestamp;
          lastTimestamp = timestamp2;
          if (message) {
            const data = message.data ? Buffer.from(message.data, "base64") : Buffer.alloc(0);
            const msg = Object.assign({}, message, { data });
            this.push({ type, delay, msg });
          } else {
            this.push({ type, delay, msg: null });
          }
        } else {
          this.push(null);
        }
      }
    });
  }
};

// src/components/component.ts
var AbstractComponent = class {
  constructor() {
    __publicField(this, "_incomingErrorHandler");
    __publicField(this, "_outgoingErrorHandler");
  }
};
var Source = class _Source extends AbstractComponent {
  constructor(incoming = new import_stream2.Readable({ objectMode: true }), outgoing = new import_stream2.Writable({ objectMode: true })) {
    super();
    __publicField(this, "incoming");
    __publicField(this, "outgoing");
    __publicField(this, "next");
    __publicField(this, "prev");
    this.incoming = incoming;
    this.outgoing = outgoing;
    this.next = null;
    this.prev = null;
  }
  /**
   * Set up a source component that has a message list as data source.
   *
   * @param messages - List of objects (with data property) to emit on the
   * incoming stream
   */
  static fromMessages(messages) {
    const component = new _Source(
      StreamFactory.producer(messages),
      StreamFactory.consumer()
    );
    return component;
  }
  /**
   * Attach another component so the the 'down' stream flows into the
   * next component 'down' stream and the 'up' stream of the other component
   * flows into the 'up' stream of this component. This is what establishes the
   * meaning of 'up' and 'down'.
   * @param  next - The component to connect.
   * @return A reference to the connected component.
   *
   *      -------------- pipe --------------
   *  <-  |  outgoing  |  <-  |  outgoing  | <-
   *      |    this    |      |    next    |
   *  ->  |  incoming  |  ->  |  incoming  | ->
   *      -------------- pipe --------------
   */
  connect(next) {
    if (next === null) {
      return this;
    } else if (this.next !== null || next.prev !== null) {
      throw new Error("connection failed: component(s) already connected");
    }
    if (!this.incoming.readable || !this.outgoing.writable) {
      throw new Error("connection failed: this component not compatible");
    }
    if (!next.incoming.writable || !next.outgoing.readable) {
      throw new Error("connection failed: next component not compatible");
    }
    try {
      this.incoming.pipe(next.incoming);
      next.outgoing.pipe(this.outgoing);
    } catch (e) {
      throw new Error(`connection failed: ${e.message}`);
    }
    const incomingErrorHandler = (err) => {
      this.incoming.emit("error", err);
    };
    next.incoming.on("error", incomingErrorHandler);
    const outgoingErrorHandler = (err) => {
      next.outgoing.emit("error", err);
    };
    this.outgoing.on("error", outgoingErrorHandler);
    this.next = next;
    next.prev = this;
    this._incomingErrorHandler = incomingErrorHandler;
    this._outgoingErrorHandler = outgoingErrorHandler;
    return next;
  }
  /**
   * Disconnect the next connected component. When there is no next component
   * the function will just do nothing.
   * @return {Component} - A reference to this component.
   */
  disconnect() {
    const next = this.next;
    if (next !== null) {
      this.incoming.unpipe(next.incoming);
      next.outgoing.unpipe(this.outgoing);
      if (typeof this._incomingErrorHandler !== "undefined") {
        next.incoming.removeListener("error", this._incomingErrorHandler);
      }
      if (typeof this._outgoingErrorHandler !== "undefined") {
        this.outgoing.removeListener("error", this._outgoingErrorHandler);
      }
      this.next = null;
      next.prev = null;
      delete this._incomingErrorHandler;
      delete this._outgoingErrorHandler;
    }
    return this;
  }
};
var Tube = class _Tube extends Source {
  constructor(incoming = new import_stream2.PassThrough({ objectMode: true }), outgoing = new import_stream2.PassThrough({ objectMode: true })) {
    super(incoming, outgoing);
    __publicField(this, "incoming");
    __publicField(this, "outgoing");
    this.incoming = incoming;
    this.outgoing = outgoing;
  }
  /**
   * Create a component that calls a handler function for each message passing
   * through, but otherwise just passes data through.
   *
   * Can be used to log messages passing through a pipeline.
   */
  static fromHandlers(fnIncoming, fnOutgoing) {
    const incomingStream = fnIncoming ? StreamFactory.peeker(fnIncoming) : void 0;
    const outgoingStream = fnOutgoing ? StreamFactory.peeker(fnOutgoing) : void 0;
    return new _Tube(incomingStream, outgoingStream);
  }
};
var Sink = class _Sink extends AbstractComponent {
  constructor(incoming = new import_stream2.Writable({ objectMode: true }), outgoing = new import_stream2.Readable({ objectMode: true })) {
    super();
    __publicField(this, "incoming");
    __publicField(this, "outgoing");
    __publicField(this, "next");
    __publicField(this, "prev");
    this.incoming = incoming;
    this.outgoing = outgoing;
    this.next = null;
    this.prev = null;
  }
  /**
   * Create a component that swallows incoming data (calling fn on it).  To
   * print data, you would use fn = console.log.
   *
   * @param fn - The callback to use for the incoming data.
   */
  static fromHandler(fn) {
    const component = new _Sink(
      StreamFactory.consumer(fn),
      StreamFactory.producer(void 0)
    );
    component.incoming.on("finish", () => {
      component.outgoing.push(null);
    });
    return component;
  }
  connect() {
    throw new Error("connection failed: attempting to connect after a sink");
  }
  disconnect() {
    return this;
  }
};

// src/components/aacdepay/index.ts
init_polyfill();

// src/utils/protocols/rtp.ts
init_polyfill();

// src/utils/bits.ts
init_polyfill();
var POS = [128, 64, 32, 16, 8, 4, 2, 1];

// src/utils/protocols/rtp.ts
var version = (buffer) => {
  return buffer[0] >>> 6;
};
var padding = (buffer) => {
  return !!(buffer[0] & POS[2]);
};
var extension = (buffer) => {
  return !!(buffer[0] & POS[3]);
};
var cSrcCount = (buffer) => {
  return buffer[0] & 15;
};
var marker = (buffer) => {
  return !!(buffer[1] & POS[0]);
};
var payloadType = (buffer) => {
  return buffer[1] & 127;
};
var sequenceNumber = (buffer) => {
  return buffer.readUInt16BE(2);
};
var timestamp = (buffer) => {
  return buffer.readUInt32BE(4);
};
var sSrc = (buffer) => {
  return buffer.readUInt32BE(8);
};
var cSrc = (buffer, rank = 0) => {
  return cSrcCount(buffer) > rank ? buffer.readUInt32BE(12 + rank * 4) : 0;
};
var extHeaderLength = (buffer) => {
  return !extension(buffer) ? 0 : buffer.readUInt16BE(12 + cSrcCount(buffer) * 4 + 2);
};
var extHeader = (buffer) => {
  return extHeaderLength(buffer) === 0 ? Buffer.from([]) : buffer.slice(
    12 + cSrcCount(buffer) * 4,
    12 + cSrcCount(buffer) * 4 + 4 + extHeaderLength(buffer) * 4
  );
};
var payload = (buffer) => {
  return !extension(buffer) ? buffer.slice(12 + cSrcCount(buffer) * 4) : buffer.slice(12 + cSrcCount(buffer) * 4 + 4 + extHeaderLength(buffer) * 4);
};

// src/components/message.ts
init_polyfill();
var MessageType = /* @__PURE__ */ ((MessageType2) => {
  MessageType2[MessageType2["UNKNOWN"] = 0] = "UNKNOWN";
  MessageType2[MessageType2["RAW"] = 1] = "RAW";
  MessageType2[MessageType2["RTP"] = 2] = "RTP";
  MessageType2[MessageType2["RTCP"] = 3] = "RTCP";
  MessageType2[MessageType2["RTSP"] = 4] = "RTSP";
  MessageType2[MessageType2["SDP"] = 5] = "SDP";
  MessageType2[MessageType2["ELEMENTARY"] = 6] = "ELEMENTARY";
  MessageType2[MessageType2["H264"] = 7] = "H264";
  MessageType2[MessageType2["ISOM"] = 8] = "ISOM";
  MessageType2[MessageType2["XML"] = 9] = "XML";
  MessageType2[MessageType2["JPEG"] = 10] = "JPEG";
  return MessageType2;
})(MessageType || {});

// src/components/messageStreams.ts
init_polyfill();
var import_stream3 = __toESM(require_stream_browserify());
var createTransform = (transform) => {
  return new import_stream3.Transform({
    objectMode: true,
    transform
  });
};

// src/components/aacdepay/parser.ts
init_polyfill();
function parse(rtp, hasHeader, callback) {
  const buffer = payload(rtp.data);
  let headerLength = 0;
  if (hasHeader) {
    const auHeaderLengthInBits = buffer.readUInt16BE(0);
    headerLength = 2 + (auHeaderLengthInBits + auHeaderLengthInBits % 8) / 8;
  }
  const packet = {
    type: 6 /* ELEMENTARY */,
    data: buffer.slice(headerLength),
    payloadType: payloadType(rtp.data),
    timestamp: timestamp(rtp.data),
    ntpTimestamp: rtp.ntpTimestamp
  };
  callback(packet);
}

// src/components/aacdepay/index.ts
var AACDepay = class extends Tube {
  constructor() {
    let AACPayloadType;
    let hasHeader;
    const incoming = createTransform(function(msg, encoding, callback) {
      if (msg.type === 5 /* SDP */) {
        let validMedia;
        for (const media of msg.sdp.media) {
          if (media.type === "audio" && media.fmtp && media.fmtp.parameters && media.fmtp.parameters.mode === "AAC-hbr") {
            validMedia = media;
          }
        }
        if (validMedia && validMedia.rtpmap !== void 0) {
          AACPayloadType = Number(validMedia.rtpmap.payloadType);
          const parameters = validMedia.fmtp.parameters;
          const sizeLength = Number(parameters.sizelength) || 0;
          const indexLength = Number(parameters.indexlength) || 0;
          const indexDeltaLength = Number(parameters.indexdeltalength) || 0;
          const CTSDeltaLength = Number(parameters.ctsdeltalength) || 0;
          const DTSDeltaLength = Number(parameters.dtsdeltalength) || 0;
          const RandomAccessIndication = Number(parameters.randomaccessindication) || 0;
          const StreamStateIndication = Number(parameters.streamstateindication) || 0;
          const AuxiliaryDataSizeLength = Number(parameters.auxiliarydatasizelength) || 0;
          hasHeader = sizeLength + Math.max(indexLength, indexDeltaLength) + CTSDeltaLength + DTSDeltaLength + RandomAccessIndication + StreamStateIndication + AuxiliaryDataSizeLength > 0;
        }
        callback(void 0, msg);
      } else if (msg.type === 2 /* RTP */ && payloadType(msg.data) === AACPayloadType) {
        parse(msg, hasHeader, this.push.bind(this));
        callback();
      } else {
        callback(void 0, msg);
      }
    });
    super(incoming);
  }
};

// src/components/basicdepay/index.ts
init_polyfill();
var BasicDepay = class extends Tube {
  constructor(rtpPayloadType) {
    if (rtpPayloadType === void 0) {
      throw new Error("you must supply a payload type to BasicDepayComponent");
    }
    let buffer = Buffer.alloc(0);
    const incoming = createTransform(function(msg, encoding, callback) {
      if (msg.type === 2 /* RTP */ && payloadType(msg.data) === rtpPayloadType) {
        const rtpPayload = payload(msg.data);
        buffer = Buffer.concat([buffer, rtpPayload]);
        if (marker(msg.data)) {
          if (buffer.length > 0) {
            this.push({
              data: buffer,
              timestamp: timestamp(msg.data),
              ntpTimestamp: msg.ntpTimestamp,
              payloadType: payloadType(msg.data),
              type: 6 /* ELEMENTARY */
            });
          }
          buffer = Buffer.alloc(0);
        }
        callback();
      } else {
        callback(void 0, msg);
      }
    });
    super(incoming);
  }
};

// src/components/canvas/index.ts
init_polyfill();
var import_stream4 = __toESM(require_stream_browserify());

// src/utils/clock.ts
init_polyfill();
var Clock = class {
  constructor() {
    __publicField(this, "started");
    __publicField(this, "stopped");
    __publicField(this, "elapsed");
    this.elapsed = 0;
    this.started = 0;
    this.stopped = true;
  }
  start() {
    if (this.stopped) {
      this.started = window.performance.now();
      this.stopped = false;
    }
  }
  stop() {
    if (!this.stopped) {
      this.elapsed = this.now();
      this.stopped = true;
    }
  }
  reset() {
    this.elapsed = 0;
    this.started = 0;
    this.stopped = true;
  }
  // Gives the elapsed time in milliseconds since the
  // clock was first started (after last reset).
  now() {
    if (this.stopped) {
      return this.elapsed;
    }
    return this.elapsed + (window.performance.now() - this.started);
  }
  play() {
    this.start();
  }
  pause() {
    this.stop();
  }
  // Gives the elapsed time in seconds since last reset.
  get currentTime() {
    return this.now() / 1e3;
  }
};

// src/utils/scheduler.ts
init_polyfill();
var DEFAULT_TOLERANCE = 10;
var Scheduler = class {
  /**
   * Creates an instance of Scheduler.
   * @param clock - The clock to use (so we can control playback)
   * @param handler - The callback to invoke when a message is in sync
   * @param tolerance - The milliseconds defining "in sync" (default = 10)
   */
  constructor(clock, handler, tolerance = DEFAULT_TOLERANCE) {
    __publicField(this, "_clock");
    __publicField(this, "_handler");
    __publicField(this, "_tolerance");
    __publicField(this, "_nextRun");
    __publicField(this, "_nextPlay");
    __publicField(this, "_fifo");
    __publicField(this, "_ntpPresentationTime");
    __publicField(this, "_suspended");
    this._clock = clock;
    this._handler = handler;
    this._tolerance = tolerance;
    this._nextRun = 0;
    this._nextPlay = 0;
    this._fifo = [];
    this._ntpPresentationTime = 0;
    this._suspended = false;
  }
  /**
   * Bring the scheduler back to it's initial state.
   */
  reset() {
    clearTimeout(this._nextRun);
    clearTimeout(this._nextPlay);
    this._fifo = [];
    this._ntpPresentationTime = 0;
    this._suspended = false;
  }
  /**
   * Initialize the scheduler.
   *
   * @param ntpPresentationTime - The offset representing the start of the presentation
   */
  init(ntpPresentationTime) {
    this._ntpPresentationTime = ntpPresentationTime;
  }
  /**
   * Suspend the scheduler.
   *
   * This releases control of the clock and stops any scheduling activity.
   * Note that this doesn't mean the clock will be in a particular state
   * (could be started or stopped), just that the scheduler will no longer
   * control it.
   */
  suspend() {
    clearTimeout(this._nextPlay);
    this._suspended = true;
  }
  /**
   * Resume the scheduler.
   *
   * This gives back control of the clock and the ability
   * to schedule messages. The scheduler will immediately
   * try to do that on resume.
   */
  resume() {
    this._suspended = false;
    this.run(void 0);
  }
  /**
   * Run the scheduler.
   *
   * @param newMessage - New message to schedule.
   */
  run(newMessage) {
    clearTimeout(this._nextRun);
    if (typeof this._ntpPresentationTime === "undefined") {
      return;
    }
    if (typeof newMessage !== "undefined") {
      this._fifo.push(newMessage);
    }
    if (this._suspended) {
      return;
    }
    if (this._fifo.length === 0) {
      return;
    }
    let timeToPresent = 0;
    let currentMessage;
    do {
      const msg = this._fifo.shift();
      if (msg === void 0) {
        throw new Error("internal error: message should never be undefined");
      }
      currentMessage = msg;
      const ntpTimestamp = currentMessage.ntpTimestamp;
      if (ntpTimestamp === void 0) {
        continue;
      }
      const presentationTime = ntpTimestamp - this._ntpPresentationTime;
      timeToPresent = presentationTime - this._clock.currentTime * 1e3;
      if (Math.abs(timeToPresent) < this._tolerance) {
        this._handler && this._handler(currentMessage);
      }
    } while (timeToPresent < this._tolerance && this._fifo.length > 0);
    if (timeToPresent < -this._tolerance) {
      clearTimeout(this._nextPlay);
      this._clock.pause();
      this._nextPlay = window.setTimeout(
        () => this._clock.play(),
        -timeToPresent
      );
    } else if (timeToPresent > this._tolerance) {
      this._fifo.unshift(currentMessage);
      this._nextRun = window.setTimeout(
        () => this.run(void 0),
        timeToPresent
      );
    }
  }
};

// src/components/canvas/index.ts
var resetInfo = (info) => {
  info.bitrate = 0;
  info.framerate = 0;
  info.renderedFrames = 0;
};
var generateUpdateInfo = (clockrate) => {
  let cumulativeByteLength = 0;
  let cumulativeDuration = 0;
  let cumulativeFrames = 0;
  return (info, { byteLength, duration }) => {
    cumulativeByteLength += byteLength;
    cumulativeDuration += duration;
    cumulativeFrames++;
    if (cumulativeDuration >= clockrate) {
      const bits = 8 * cumulativeByteLength;
      const frames = cumulativeFrames;
      const seconds = cumulativeDuration / clockrate;
      info.bitrate = bits / seconds;
      info.framerate = frames / seconds;
      cumulativeByteLength = 0;
      cumulativeDuration = 0;
      cumulativeFrames = 0;
    }
  };
};
var CanvasSink = class extends Sink {
  /**
   * @param  el - The <canvas> element to draw incoming JPEG messages on.
   */
  constructor(el) {
    if (el === void 0) {
      throw new Error("canvas element argument missing");
    }
    let firstTimestamp = 0;
    let lastTimestamp = 0;
    let clockrate = 0;
    const info = {
      bitrate: 0,
      framerate: 0,
      renderedFrames: 0
    };
    let updateInfo;
    let ctx = null;
    if (window.createImageBitmap !== void 0) {
      ctx = el.getContext("bitmaprenderer");
    }
    if (ctx === null) {
      ctx = el.getContext("2d");
    }
    let drawImageBlob;
    if (ctx === null) {
      drawImageBlob = () => {
      };
    } else if ("transferFromImageBitmap" in ctx) {
      const ctxBitmaprenderer = ctx;
      drawImageBlob = ({ blob }) => {
        info.renderedFrames++;
        window.createImageBitmap(blob).then((imageBitmap) => {
          ctxBitmaprenderer.transferFromImageBitmap(imageBitmap);
        }).catch(() => {
        });
      };
    } else {
      const ctx2d = ctx;
      const img = new Image();
      img.onload = () => {
        ctx2d.drawImage(img, 0, 0);
      };
      drawImageBlob = ({ blob }) => {
        info.renderedFrames++;
        const url = window.URL.createObjectURL(blob);
        img.src = url;
      };
    }
    const clock = new Clock();
    const scheduler = new Scheduler(clock, drawImageBlob);
    let ntpPresentationTime = 0;
    const onCanplay = () => {
      this.onCanplay && this.onCanplay();
    };
    const onSync = (npt) => {
      this.onSync && this.onSync(npt);
    };
    const incoming = new import_stream4.Writable({
      objectMode: true,
      write: (msg, _encoding, callback) => {
        if (msg.type === 5 /* SDP */) {
          clock.reset();
          scheduler.reset();
          firstTimestamp = 0;
          const jpegMedia = msg.sdp.media.find((media) => {
            return media.type === "video" && media.rtpmap !== void 0 && media.rtpmap.encodingName === "JPEG";
          });
          if (jpegMedia !== void 0 && jpegMedia.rtpmap !== void 0) {
            clockrate = jpegMedia.rtpmap.clockrate;
            resetInfo(info);
            updateInfo = generateUpdateInfo(clockrate);
          }
          callback();
        } else if (msg.type === 10 /* JPEG */) {
          const { timestamp: timestamp2, ntpTimestamp } = msg;
          if (!firstTimestamp) {
            firstTimestamp = timestamp2;
            lastTimestamp = timestamp2;
            const { width, height } = msg.framesize;
            el.width = width;
            el.height = height;
            scheduler.init(0);
          }
          const presentationTime = 1e3 * (timestamp2 - firstTimestamp) / clockrate;
          const blob = new window.Blob([msg.data], { type: "image/jpeg" });
          if (!ntpPresentationTime && ntpTimestamp) {
            ntpPresentationTime = ntpTimestamp - presentationTime;
            onSync(ntpPresentationTime);
          }
          scheduler.run({
            ntpTimestamp: presentationTime,
            blob
          });
          if (timestamp2 === firstTimestamp) {
            onCanplay();
          }
          updateInfo(info, {
            byteLength: msg.data.length,
            duration: timestamp2 - lastTimestamp
          });
          lastTimestamp = timestamp2;
          callback();
        } else {
          callback();
        }
      }
    });
    const outgoing = new import_stream4.Readable({
      objectMode: true,
      read() {
      }
    });
    outgoing.on("error", () => {
      console.warn("outgoing stream broke somewhere");
    });
    super(incoming, outgoing);
    __publicField(this, "onCanplay");
    __publicField(this, "onSync");
    __publicField(this, "_clock");
    __publicField(this, "_scheduler");
    __publicField(this, "_info");
    this._clock = clock;
    this._scheduler = scheduler;
    this._info = info;
    this.onCanplay = void 0;
    this.onSync = void 0;
  }
  /**
   * Retrieve the current presentation time (seconds)
   */
  get currentTime() {
    return this._clock.currentTime;
  }
  /**
   * Pause the presentation.
   */
  pause() {
    this._scheduler.suspend();
    this._clock.pause();
  }
  /**
   * Start the presentation.
   */
  play() {
    this._clock.play();
    this._scheduler.resume();
  }
  get bitrate() {
    return this._info.bitrate;
  }
  get framerate() {
    return this._info.framerate;
  }
};

// src/components/h264depay/index.ts
init_polyfill();
var import_stream5 = __toESM(require_stream_browserify());

// src/components/h264depay/parser.ts
init_polyfill();
var import_debug = __toESM(require("debug"));
var h264Debug = (0, import_debug.default)("msl:h264depay");
var H264DepayParser = class {
  constructor() {
    __publicField(this, "_buffer");
    this._buffer = Buffer.alloc(0);
  }
  parse(rtp) {
    const rtpPayload = payload(rtp.data);
    const type = rtpPayload[0] & 31;
    if (type === 28) {
      const fuIndicator = rtpPayload[0];
      const fuHeader = rtpPayload[1];
      const startBit = !!(fuHeader >> 7);
      const nalType = fuHeader & 31;
      const nal = fuIndicator & 224 | nalType;
      const stopBit = fuHeader & 64;
      if (startBit) {
        this._buffer = Buffer.concat([
          Buffer.from([0, 0, 0, 0, nal]),
          rtpPayload.slice(2)
        ]);
        return null;
      } else if (stopBit) {
        const h264frame = Buffer.concat([
          this._buffer,
          rtpPayload.slice(2)
        ]);
        h264frame.writeUInt32BE(h264frame.length - 4, 0);
        const msg = {
          data: h264frame,
          type: 7 /* H264 */,
          timestamp: timestamp(rtp.data),
          ntpTimestamp: rtp.ntpTimestamp,
          payloadType: payloadType(rtp.data),
          nalType
        };
        this._buffer = Buffer.alloc(0);
        return msg;
      }
      this._buffer = Buffer.concat([this._buffer, rtpPayload.slice(2)]);
      return null;
    } else if ((type === 1 /* NON_IDR_PICTURE */ || type === 5 /* IDR_PICTURE */) && this._buffer.length === 0) {
      const h264frame = Buffer.concat([
        Buffer.from([0, 0, 0, 0]),
        rtpPayload
      ]);
      h264frame.writeUInt32BE(h264frame.length - 4, 0);
      const msg = {
        data: h264frame,
        type: 7 /* H264 */,
        timestamp: timestamp(rtp.data),
        ntpTimestamp: rtp.ntpTimestamp,
        payloadType: payloadType(rtp.data),
        nalType: type
      };
      this._buffer = Buffer.alloc(0);
      return msg;
    }
    h264Debug(
      `H264depayComponent can only extract types 1,5 and 28, got ${type}`
    );
    this._buffer = Buffer.alloc(0);
    return null;
  }
};

// src/components/h264depay/index.ts
var H264Depay = class extends Tube {
  constructor() {
    let h264PayloadType;
    let idrFound = false;
    let packets = [];
    const h264DepayParser = new H264DepayParser();
    const incoming = new import_stream5.Transform({
      objectMode: true,
      transform(msg, _encoding, callback) {
        if (msg.type === 5 /* SDP */) {
          const h264Media = msg.sdp.media.find((media) => {
            return media.type === "video" && media.rtpmap !== void 0 && media.rtpmap.encodingName === "H264";
          });
          if (h264Media !== void 0 && h264Media.rtpmap !== void 0) {
            h264PayloadType = h264Media.rtpmap.payloadType;
          }
          callback(void 0, msg);
        } else if (msg.type === 2 /* RTP */ && payloadType(msg.data) === h264PayloadType) {
          const endOfFrame = marker(msg.data);
          const h264Message = h264DepayParser.parse(msg);
          if (h264Message === null || !idrFound && h264Message.nalType !== 5 /* IDR_PICTURE */) {
            callback();
            return;
          }
          idrFound = true;
          packets.push(h264Message.data);
          if (endOfFrame) {
            this.push(__spreadProps(__spreadValues({}, h264Message), {
              data: packets.length === 1 ? packets[0] : Buffer.concat(packets)
            }));
            packets = [];
          }
          callback();
        } else {
          callback(void 0, msg);
        }
      }
    });
    super(incoming);
  }
};

// src/components/http-source/index.ts
init_polyfill();
var import_debug2 = __toESM(require("debug"));
var import_stream6 = __toESM(require_stream_browserify());
var debug2 = (0, import_debug2.default)("msl:http-source");
var HttpSource = class extends Source {
  /**
   * Create an HTTP component.
   *
   * The constructor sets a single readable stream from a fetch.
   */
  constructor(config) {
    const { uri, options } = config;
    const incoming = new import_stream6.Readable({
      objectMode: true,
      read() {
      }
    });
    incoming.on("error", (e) => {
      console.warn("closing socket due to incoming error", e);
      this._reader && this._reader.cancel().catch((err) => console.error(err));
    });
    super(incoming);
    __publicField(this, "uri");
    __publicField(this, "options");
    __publicField(this, "length");
    __publicField(this, "onHeaders");
    __publicField(this, "onServerClose");
    __publicField(this, "_reader");
    __publicField(this, "_abortController");
    __publicField(this, "_allDone");
    incoming._read = () => {
      this._pull();
    };
    this.uri = uri;
    this.options = options;
    this._allDone = false;
  }
  play() {
    if (this.uri === void 0) {
      throw new Error("cannot start playing when there is no URI");
    }
    this._abortController = new AbortController();
    this.length = 0;
    fetch(this.uri, __spreadValues({
      credentials: "include",
      signal: this._abortController.signal
    }, this.options)).then((rsp) => {
      if (rsp.body === null) {
        throw new Error("empty response body");
      }
      this.onHeaders && this.onHeaders(rsp.headers);
      this._reader = rsp.body.getReader();
      this._pull();
    }).catch((err) => {
      console.error("http-source: fetch failed: ", err);
    });
  }
  abort() {
    this._reader && this._reader.cancel().catch((err) => {
      console.log("http-source: cancel reader failed: ", err);
    });
    this._abortController && this._abortController.abort();
  }
  _isClosed() {
    return this._allDone;
  }
  _close() {
    var _a;
    this._reader = void 0;
    this._allDone = true;
    this.incoming.push(null);
    (_a = this.onServerClose) == null ? void 0 : _a.call(this);
  }
  _pull() {
    if (this._reader === void 0) {
      return;
    }
    this._reader.read().then(({ done, value }) => {
      if (done) {
        if (!this._isClosed()) {
          debug2("fetch completed, total downloaded: ", this.length, " bytes");
          this._close();
        }
        return;
      }
      if (value === void 0) {
        throw new Error("expected value to be defined");
      }
      if (this.length === void 0) {
        throw new Error("expected length to be defined");
      }
      this.length += value.length;
      const buffer = Buffer.from(value);
      if (!this.incoming.push({ data: buffer, type: 1 /* RAW */ })) {
        debug2("downstream back pressure: pausing read");
      } else {
        this._pull();
      }
    }).catch((err) => {
      debug2("http-source: read failed: ", err);
      if (!this._isClosed()) {
        this._close();
      }
    });
  }
};

// src/components/inspector/index.ts
init_polyfill();
var import_stream7 = __toESM(require_stream_browserify());
var generateLogger = (prefix, type) => {
  let lastTimestamp = Date.now();
  const log = (msg) => {
    const timestamp2 = Date.now();
    console.log(`${prefix}: +${timestamp2 - lastTimestamp}ms`, msg);
    lastTimestamp = timestamp2;
  };
  if (type === void 0) {
    return log;
  }
  return (msg) => msg.type === type && log(msg);
};
var Inspector = class extends Tube {
  /**
   * Create a new inspector component.
   * @argument {String} type  The type of message to log (default is to log all).
   * @return {undefined}
   */
  constructor(type) {
    const incomingLogger = generateLogger("incoming", type);
    const incoming = new import_stream7.Transform({
      objectMode: true,
      transform(msg, encoding, callback) {
        incomingLogger(msg);
        callback(void 0, msg);
      }
    });
    const outgoingLogger = generateLogger("outgoing", type);
    const outgoing = new import_stream7.Transform({
      objectMode: true,
      transform(msg, encoding, callback) {
        outgoingLogger(msg);
        callback(void 0, msg);
      }
    });
    super(incoming, outgoing);
  }
};

// src/components/jpegdepay/index.ts
init_polyfill();
var import_stream8 = __toESM(require_stream_browserify());

// src/components/jpegdepay/parser.ts
init_polyfill();

// src/components/jpegdepay/headers.ts
init_polyfill();
function makeImageHeader() {
  return Buffer.from([255, 216]);
}
function makeQuantHeader(precision, qTable) {
  const lumSize = precision & 1 ? 128 : 64;
  const chmSize = precision & 2 ? 128 : 64;
  if (qTable.length !== lumSize + chmSize) {
    throw new Error("invalid quantization table");
  }
  const lumaPrefix = Buffer.from([255, 219, 0, lumSize + 3, 0]);
  const chromaPrefix = Buffer.from([255, 219, 0, chmSize + 3, 1]);
  return Buffer.concat([
    lumaPrefix,
    qTable.slice(0, lumSize),
    chromaPrefix,
    qTable.slice(lumSize)
  ]);
}
function makeFrameHeader(width, height, type) {
  return Buffer.from([
    255,
    192,
    // SOF_0 (Start Of Frame)
    0,
    17,
    8,
    height >> 8,
    height,
    width >> 8,
    width,
    3,
    0,
    type === 0 ? 33 : 34,
    0,
    1,
    17,
    1,
    2,
    17,
    1
  ]);
}
var LUM_DC_CODELENS = [
  0,
  1,
  5,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];
var LUM_DC_SYMBOLS = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11
];
var LUM_AC_CODELENS = [
  0,
  2,
  1,
  3,
  3,
  2,
  4,
  3,
  5,
  5,
  4,
  4,
  0,
  0,
  1,
  125
];
var LUM_AC_SYMBOLS = [
  1,
  2,
  3,
  0,
  4,
  17,
  5,
  18,
  33,
  49,
  65,
  6,
  19,
  81,
  97,
  7,
  34,
  113,
  20,
  50,
  129,
  145,
  161,
  8,
  35,
  66,
  177,
  193,
  21,
  82,
  209,
  240,
  36,
  51,
  98,
  114,
  130,
  9,
  10,
  22,
  23,
  24,
  25,
  26,
  37,
  38,
  39,
  40,
  41,
  42,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250
];
var CHM_DC_CODELENS = [
  0,
  3,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0
];
var CHM_DC_SYMBOLS = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11
];
var CHM_AC_CODELENS = [
  0,
  2,
  1,
  2,
  4,
  4,
  3,
  4,
  7,
  5,
  4,
  4,
  0,
  1,
  2,
  119
];
var CHM_AC_SYMBOLS = [
  0,
  1,
  2,
  3,
  17,
  4,
  5,
  33,
  49,
  6,
  18,
  65,
  81,
  7,
  97,
  113,
  19,
  34,
  50,
  129,
  8,
  20,
  66,
  145,
  161,
  177,
  193,
  9,
  35,
  51,
  82,
  240,
  21,
  98,
  114,
  209,
  10,
  22,
  36,
  52,
  225,
  37,
  241,
  23,
  24,
  25,
  26,
  38,
  39,
  40,
  41,
  42,
  53,
  54,
  55,
  56,
  57,
  58,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250
];
function makeHuffmanHeader() {
  const LUM_DC_BUFFER = [
    [
      255,
      196,
      0,
      3 + LUM_DC_CODELENS.length + LUM_DC_SYMBOLS.length,
      0 << 4 | 0
    ],
    LUM_DC_CODELENS,
    LUM_DC_SYMBOLS
  ];
  const LUM_AC_BUFFER = [
    [
      255,
      196,
      0,
      3 + LUM_AC_CODELENS.length + LUM_AC_SYMBOLS.length,
      1 << 4 | 0
    ],
    LUM_AC_CODELENS,
    LUM_AC_SYMBOLS
  ];
  const CHM_DC_BUFFER = [
    [
      255,
      196,
      0,
      3 + CHM_DC_CODELENS.length + CHM_DC_SYMBOLS.length,
      0 << 4 | 1
    ],
    CHM_DC_CODELENS,
    CHM_DC_SYMBOLS
  ];
  const CHM_AC_BUFFER = [
    [
      255,
      196,
      0,
      3 + CHM_AC_CODELENS.length + CHM_AC_SYMBOLS.length,
      1 << 4 | 1
    ],
    CHM_AC_CODELENS,
    CHM_AC_SYMBOLS
  ];
  return Buffer.concat([
    ...LUM_DC_BUFFER.map(Buffer.from),
    ...LUM_AC_BUFFER.map(Buffer.from),
    ...CHM_DC_BUFFER.map(Buffer.from),
    ...CHM_AC_BUFFER.map(Buffer.from)
  ]);
}
function makeScanHeader() {
  return Buffer.from([
    255,
    218,
    // SOS (Start Of Scan)
    0,
    12,
    3,
    0,
    0,
    1,
    17,
    2,
    17,
    0,
    63,
    0
  ]);
}
function makeDRIHeader(dri) {
  return Buffer.from([255, 221, 0, 4, dri >> 8, dri & 255]);
}

// src/components/jpegdepay/make-qtable.ts
init_polyfill();

// src/utils/clamp.ts
init_polyfill();
function clamp(val, min, max) {
  return val > max ? max : val < min ? min : val;
}

// src/components/jpegdepay/make-qtable.ts
var jpegLumaQuantizer = [
  16,
  11,
  12,
  14,
  12,
  10,
  16,
  14,
  13,
  14,
  18,
  17,
  16,
  19,
  24,
  40,
  26,
  24,
  22,
  22,
  24,
  49,
  35,
  37,
  29,
  40,
  58,
  51,
  61,
  60,
  57,
  51,
  56,
  55,
  64,
  72,
  92,
  78,
  64,
  68,
  87,
  69,
  55,
  56,
  80,
  109,
  81,
  87,
  95,
  98,
  103,
  104,
  103,
  62,
  77,
  113,
  121,
  112,
  100,
  120,
  92,
  101,
  103,
  99
];
var jpeChromaQuantizer = [
  17,
  18,
  18,
  24,
  21,
  24,
  47,
  26,
  26,
  47,
  99,
  66,
  56,
  66,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99,
  99
];
function makeQtable(Q) {
  const factor = clamp(Q, 1, 99);
  const buffer = Buffer.alloc(128);
  const S = Q < 50 ? Math.floor(5e3 / factor) : 200 - factor * 2;
  for (let i = 0; i < 64; i++) {
    const lq = Math.floor((jpegLumaQuantizer[i] * S + 50) / 100);
    const cq = Math.floor((jpeChromaQuantizer[i] * S + 50) / 100);
    buffer.writeUInt8(clamp(lq, 1, 255), i);
    buffer.writeUInt8(clamp(cq, 1, 255), i + 64);
  }
  return buffer;
}

// src/components/jpegdepay/parser.ts
function jpegDepayFactory(defaultWidth = 0, defaultHeight = 0) {
  const IMAGE_HEADER = makeImageHeader();
  const HUFFMAN_HEADER = makeHuffmanHeader();
  const SCAN_HEADER = makeScanHeader();
  return function jpegDepay(packets) {
    let metadata;
    const fragments = [];
    for (const packet of packets) {
      let fragment = payload(packet);
      const typeSpecific = fragment.readUInt8(0);
      const fragmentOffset = fragment.readUInt8(1) << 16 | fragment.readUInt8(2) << 8 | fragment.readUInt8(3);
      const type2 = fragment.readUInt8(4);
      const Q = fragment.readUInt8(5);
      const width2 = fragment.readUInt8(6) * 8 || defaultWidth;
      const height2 = fragment.readUInt8(7) * 8 || defaultHeight;
      fragment = fragment.slice(8);
      let DRI = 0;
      if (type2 >= 64 && type2 <= 127) {
        DRI = fragment.readUInt16BE(0);
        fragment = fragment.slice(4);
      }
      if (Q >= 128 && fragmentOffset === 0) {
        const precision2 = fragment.readUInt8(1);
        const length = fragment.readUInt16BE(2);
        const qTable2 = fragment.slice(4, 4 + length);
        metadata = {
          typeSpecific,
          type: type2,
          width: width2,
          height: height2,
          DRI,
          precision: precision2,
          qTable: qTable2
        };
        fragment = fragment.slice(4 + length);
      } else if (Q < 128 && fragmentOffset === 0) {
        const precision2 = 0;
        const qTable2 = makeQtable(Q);
        metadata = {
          typeSpecific,
          type: type2,
          width: width2,
          height: height2,
          DRI,
          precision: precision2,
          qTable: qTable2
        };
      }
      fragments.push(fragment);
    }
    if (metadata === void 0) {
      throw new Error("no quantization header present");
    }
    const { precision, qTable, type, width, height } = metadata;
    const quantHeader = makeQuantHeader(precision, qTable);
    const driHeader = metadata.DRI === 0 ? Buffer.alloc(0) : makeDRIHeader(metadata.DRI);
    const frameHeader = makeFrameHeader(width, height, type);
    return {
      size: { width, height },
      data: Buffer.concat([
        IMAGE_HEADER,
        quantHeader,
        driHeader,
        frameHeader,
        HUFFMAN_HEADER,
        SCAN_HEADER,
        ...fragments
      ])
    };
  };
}

// src/components/jpegdepay/index.ts
var JPEGDepay = class extends Tube {
  constructor() {
    let jpegPayloadType;
    let packets = [];
    let jpegDepay;
    const incoming = new import_stream8.Transform({
      objectMode: true,
      transform(msg, encoding, callback) {
        if (msg.type === 5 /* SDP */) {
          const jpegMedia = msg.sdp.media.find((media) => {
            return media.type === "video" && media.rtpmap !== void 0 && media.rtpmap.encodingName === "JPEG";
          });
          if (jpegMedia !== void 0 && jpegMedia.rtpmap !== void 0) {
            jpegPayloadType = Number(jpegMedia.rtpmap.payloadType);
            const framesize = jpegMedia.framesize;
            if (framesize !== void 0) {
              const [width, height] = framesize;
              jpegDepay = jpegDepayFactory(width, height);
            } else {
              jpegDepay = jpegDepayFactory();
            }
          }
          callback(void 0, msg);
        } else if (msg.type === 2 /* RTP */ && payloadType(msg.data) === jpegPayloadType) {
          packets.push(msg.data);
          if (marker(msg.data) && packets.length > 0) {
            const jpegFrame = jpegDepay(packets);
            this.push({
              timestamp: timestamp(msg.data),
              ntpTimestamp: msg.ntpTimestamp,
              payloadType: payloadType(msg.data),
              data: jpegFrame.data,
              framesize: jpegFrame.size,
              type: 10 /* JPEG */
            });
            packets = [];
          }
          callback();
        } else {
          callback(void 0, msg);
        }
      }
    });
    super(incoming);
  }
};

// src/components/mp4capture/index.ts
init_polyfill();
var import_debug3 = __toESM(require("debug"));
var import_stream9 = __toESM(require_stream_browserify());
var MAX_CAPTURE_BYTES = 225e6;
var Mp4Capture = class extends Tube {
  constructor(maxSize = MAX_CAPTURE_BYTES) {
    const incoming = new import_stream9.Transform({
      objectMode: true,
      transform: (msg, _encoding, callback) => {
        if (this._active && msg.type === 8 /* ISOM */ && msg.tracks !== void 0) {
          this._capture = true;
        }
        if (this._capture && msg.type === 8 /* ISOM */) {
          if (this._bufferOffset < this._buffer.byteLength - msg.data.byteLength) {
            msg.data.copy(this._buffer, this._bufferOffset);
            this._bufferOffset += msg.data.byteLength;
          } else {
            this.stop();
          }
        }
        callback(void 0, msg);
      }
    });
    incoming.on("finish", () => {
      this.stop();
    });
    super(incoming);
    __publicField(this, "_active");
    __publicField(this, "_capture");
    __publicField(this, "_captureCallback");
    __publicField(this, "_bufferOffset");
    __publicField(this, "_bufferSize");
    __publicField(this, "_buffer");
    this._buffer = Buffer.allocUnsafe(0);
    this._bufferSize = maxSize;
    this._bufferOffset = 0;
    this._active = false;
    this._capture = false;
    this._captureCallback = () => {
    };
  }
  /**
   * Activate video capture. The capture will begin when a new movie starts,
   * and will terminate when the movie ends or when the buffer is full. On
   * termination, the callback you passed will be called with the captured
   * data as argument.
   * @param callback  Will be called when data is captured.
   */
  start(callback) {
    if (!this._active) {
      (0, import_debug3.default)("msl:capture:start")(callback);
      this._captureCallback = callback;
      this._buffer = Buffer.allocUnsafe(this._bufferSize);
      this._bufferOffset = 0;
      this._active = true;
    }
  }
  /**
   * Deactivate video capture. This ends an ongoing capture and prevents
   * any further capturing.
   */
  stop() {
    if (this._active) {
      (0, import_debug3.default)("msl:capture:stop")(`captured bytes: ${this._bufferOffset}`);
      try {
        this._captureCallback(this._buffer.slice(0, this._bufferOffset));
      } catch (e) {
        console.error(e);
      }
      this._buffer = Buffer.allocUnsafe(0);
      this._bufferOffset = 0;
      this._active = false;
      this._capture = false;
    }
  }
};

// src/components/mp4muxer/index.ts
init_polyfill();
var import_debug4 = __toESM(require("debug"));
var import_stream10 = __toESM(require_stream_browserify());

// src/components/mp4muxer/helpers/boxbuilder.ts
init_polyfill();

// src/components/mp4muxer/helpers/aacSettings.ts
init_polyfill();

// src/components/mp4muxer/helpers/isom.ts
init_polyfill();
var UINT32_RANGE = Math.pow(2, 32);
var BoxElement = class {
  constructor(size) {
    __publicField(this, "byteLength");
    __publicField(this, "value");
    this.byteLength = size;
  }
};
var Empty = class extends BoxElement {
  constructor(size = 0) {
    super(size);
    __publicField(this, "copy", (buffer, offset) => {
      buffer.fill(0, offset, offset + this.byteLength);
    });
  }
  load() {
  }
};
var CharArray = class extends BoxElement {
  constructor(s) {
    super(s.length);
    __publicField(this, "value");
    __publicField(this, "copy", (buffer, offset) => {
      for (let i = 0; i < this.byteLength; i += 1) {
        buffer[offset + i] = this.value.charCodeAt(i);
      }
    });
    __publicField(this, "load", (buffer, offset) => {
      this.value = buffer.slice(offset, offset + this.byteLength).toString("ascii");
    });
    this.value = s;
  }
};
var UInt8 = class extends BoxElement {
  constructor(scalar = 0) {
    super(1);
    __publicField(this, "value");
    __publicField(this, "copy", (buffer, offset) => {
      buffer.writeUInt8(this.value, offset);
    });
    __publicField(this, "load", (buffer, offset) => {
      this.value = buffer.readUInt8(offset);
    });
    this.value = scalar;
  }
};
var UInt8Array = class extends BoxElement {
  constructor(array) {
    super(array.length);
    __publicField(this, "value");
    __publicField(this, "copy", (buffer, offset) => {
      for (let i = 0; i < this.value.length; ++i) {
        buffer.writeUInt8(this.value[i], offset + i);
      }
    });
    __publicField(this, "load", (buffer, offset) => {
      for (let i = 0; i < this.value.length; ++i) {
        this.value[i] = buffer.readUInt8(offset + i);
      }
    });
    this.value = array;
  }
};
var UInt16BE = class extends BoxElement {
  constructor(scalar = 0) {
    super(2);
    __publicField(this, "value");
    __publicField(this, "copy", (buffer, offset) => {
      buffer.writeUInt16BE(this.value, offset);
    });
    __publicField(this, "load", (buffer, offset) => {
      this.value = buffer.readUInt16BE(offset);
    });
    this.value = scalar;
  }
};
var UInt24BE = class extends BoxElement {
  constructor(scalar = 0) {
    super(3);
    __publicField(this, "value");
    __publicField(this, "copy", (buffer, offset) => {
      buffer.writeUInt8(this.value >> 16 & 255, offset);
      buffer.writeUInt8(this.value >> 8 & 255, offset + 1);
      buffer.writeUInt8(this.value & 255, offset + 2);
    });
    __publicField(this, "load", (buffer, offset) => {
      this.value = buffer.readUInt8(offset) << 16 + buffer.readUInt8(offset + 1) << 8 + buffer.readUInt8(offset + 2);
    });
    this.value = scalar;
  }
};
var UInt16BEArray = class extends BoxElement {
  constructor(array) {
    super(array.length * 2);
    __publicField(this, "value");
    __publicField(this, "copy", (buffer, offset) => {
      for (let i = 0; i < this.value.length; ++i) {
        buffer.writeUInt16BE(this.value[i], offset + 2 * i);
      }
    });
    __publicField(this, "load", (buffer, offset) => {
      for (let i = 0; i < this.value.length; ++i) {
        this.value[i] = buffer.readUInt16BE(offset + 2 * i);
      }
    });
    this.value = array;
  }
};
var UInt32BE = class extends BoxElement {
  constructor(scalar = 0) {
    super(4);
    __publicField(this, "value");
    __publicField(this, "copy", (buffer, offset) => {
      buffer.writeUInt32BE(this.value, offset);
    });
    __publicField(this, "load", (buffer, offset) => {
      this.value = buffer.readUInt32BE(offset);
    });
    this.value = scalar;
  }
};
var UInt32BEArray = class extends BoxElement {
  constructor(array) {
    super(array.length * 4);
    __publicField(this, "value");
    __publicField(this, "copy", (buffer, offset) => {
      for (let i = 0; i < this.value.length; ++i) {
        buffer.writeUInt32BE(this.value[i], offset + 4 * i);
      }
    });
    __publicField(this, "load", (buffer, offset) => {
      for (let i = 0; i < this.value.length; ++i) {
        this.value[i] = buffer.readUInt32BE(offset + 4 * i);
      }
    });
    this.value = array;
  }
};
var UInt64BE = class extends BoxElement {
  constructor(scalar = 0) {
    super(8);
    __publicField(this, "value");
    __publicField(this, "copy", (buffer, offset) => {
      const high = this.value / UINT32_RANGE | 0;
      const low = this.value - high * UINT32_RANGE;
      buffer.writeUInt32BE(high, offset);
      buffer.writeUInt32BE(low, offset + 4);
    });
    __publicField(this, "load", (buffer, offset) => {
      const high = buffer.readUInt32BE(offset);
      const low = buffer.readUInt32BE(offset + 4);
      this.value = high * UINT32_RANGE + low;
    });
    this.value = scalar;
  }
};
var createParameterSetArrayClass = function(sizeMask = 0) {
  return class ParameterSetArray extends BoxElement {
    /**
     * Takes an array of byte-arrays
     * @param  array The array of byte arrays
     */
    constructor(array) {
      super(0);
      __publicField(this, "value");
      __publicField(this, "copy", (buffer, offset) => {
        let i = 0;
        for (const element of this.value) {
          element.copy(buffer, offset + i);
          i += element.byteLength;
        }
      });
      __publicField(this, "load", () => {
      });
      this.value = array.reduce(
        (flatArray, byteArray) => {
          return flatArray.concat(
            new UInt16BE(byteArray.length),
            new UInt8Array(byteArray)
          );
        },
        [new UInt8(sizeMask | array.length)]
      );
      this.byteLength = this.value.reduce(
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        (total, element) => total + element.byteLength,
        0
      );
    }
  };
};
var BOXSPEC = {
  // File Type Box
  ftyp: {
    container: "file",
    mandatory: true,
    quantity: "one",
    box: "Box",
    is_container: true,
    body: [
      ["major_brand", CharArray, "isom"],
      ["minor_version", UInt32BE, 0],
      ["compatible_brands", CharArray, "mp41"]
      // ['compatible_brands1', CharArray, 'iso2'],
      // ['compatible_brands2', CharArray, 'dash'],
    ]
  },
  // Movie Container
  moov: {
    container: "file",
    mandatory: true,
    quantity: "one",
    box: "Box",
    is_container: true
  },
  // Movie Data Box
  mdat: {
    container: "file",
    mandatory: false,
    quantity: "any",
    box: "Box",
    is_container: false,
    body: []
  },
  // Movie Header Box
  mvhd: {
    container: "moov",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    body: [
      ["creation_time", UInt32BE, 0],
      ["modification_time", UInt32BE, 0],
      ["timescale", UInt32BE, 1e3],
      // time-scale for entire presentation, default = milliseconds
      ["duration", UInt32BE, 4294967295],
      // length of entire presentation, default = undetermined
      ["rate", UInt32BE, 65536],
      // fixed point 16.16, preferred playback rate, default = 1.0
      ["volume", UInt16BE, 256],
      // fixed point 8.8, preferred playback volume, default = 1.0
      ["reserved", Empty, 10],
      // transformation matrix, default = unity
      [
        "matrix",
        UInt32BEArray,
        [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]
      ],
      ["pre_defined", Empty, 24],
      ["next_track_ID", UInt32BE, 4294967295]
      // next unused track ID, default = unknown
    ]
  },
  // Track Container
  trak: {
    container: "moov",
    mandatory: true,
    quantity: "one+",
    box: "Box",
    is_container: true
  },
  // Track Header Box
  tkhd: {
    container: "trak",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    // Flag values for the track header:
    // 0x000001 Track_enabled: track enabled (otherwise ignored)
    // 0x000002 Track_in_movie: track used in presentation
    // 0x000004 Track_in_preview: used when previewing presentation
    config: {
      flags: 3
      // track enabled and used in presentation
    },
    body: [
      ["creation_time", UInt32BE, 0],
      ["modification_time", UInt32BE, 0],
      ["track_ID", UInt32BE, 1],
      // Track identifier, cannot be 0
      ["reserved", Empty, 4],
      ["duration", UInt32BE, 0],
      // Duration of track using timescale of mvhd box
      ["reserved2", Empty, 8],
      ["layer", UInt16BE, 0],
      // Front-to-back ordering, lower is closer to viewer
      ["alternate_group", UInt16BE, 0],
      // Possible grouping of tracks
      ["volume", UInt16BE, 256],
      // Track's relative audio volume 8.8 fixed point
      ["reserved3", Empty, 2],
      [
        "matrix",
        UInt32BEArray,
        [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]
      ],
      ["width", UInt32BE, 0],
      // Visual presentation width, 16.16 fixed point
      ["height", UInt32BE, 0]
      // Visual presentation height, 16.16 fixed point
    ]
  },
  // Track Reference Box
  tref: {
    container: "trak",
    mandatory: false,
    quantity: "one-",
    box: "Box",
    is_container: false
  },
  // Media Container
  mdia: {
    container: "trak",
    mandatory: false,
    quantity: "one",
    box: "Box",
    is_container: true
  },
  // Media Header Box
  mdhd: {
    container: "mdia",
    mandatory: false,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    body: [
      ["creation_time", UInt32BE, 0],
      ["modification_time", UInt32BE, 0],
      ["timescale", UInt32BE, 1e3],
      // time-scale for entire presentation, default = milliseconds
      ["duration", UInt32BE, 4294967295],
      // length of entire presentation, default = undetermined
      ["language", UInt16BE, 0],
      // ISO 639-2 lanugage code, three lower-case letters, stored as
      ["pre_defined", UInt16BE, 0]
    ]
  },
  // Handler Reference Box
  hdlr: {
    container: "mdia",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    body: [
      ["predefined", UInt32BE, 0],
      ["handler_type", CharArray, "vide"],
      // 'vide', 'soun', or 'hint'
      ["reserved", Empty, 12],
      ["name", CharArray, "VideoHandler\0"]
    ]
  },
  // Media Information Container
  minf: {
    container: "mdia",
    mandatory: true,
    quantity: "one",
    box: "Box",
    is_container: true
  },
  // Video Media Header Box
  vmhd: {
    container: "minf",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    config: {
      flags: 1
    },
    body: [
      ["graphicsmode", UInt16BE, 0],
      // Composition mode of the video track, 0 = overwrite
      ["opcolor", UInt16BEArray, [0, 0, 0]]
      // Red green blue, for use by graphics modes
    ]
  },
  // Sound Media Header Box
  smhd: {
    container: "minf",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    body: [
      // Place mono track in stereo space:
      //  8.8 fixed point, 0 = center, -1.0 = left, 1.0 = right
      ["balance", UInt16BE, 0],
      ["reserved", UInt16BE]
    ]
  },
  // Data Information Container
  dinf: {
    container: "minf",
    mandatory: true,
    quantity: "one",
    box: "Box",
    is_container: true
  },
  // Data Reference Box
  dref: {
    // When adding elements to this box, update the entry_count value!
    container: "dinf",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: true,
    body: [
      ["entry_count", UInt32BE, 0]
      // Number of entries.
    ]
  },
  "url ": {
    container: "dref",
    mandatory: true,
    quantity: "one+",
    box: "FullBox",
    is_container: false,
    // Flag values:
    // 0x000001 Local reference, which means empty URL
    config: {
      flags: 1
    },
    body: [
      // ['location', CharArray, ''],
    ]
  },
  // Sample Table Container
  stbl: {
    container: "minf",
    mandatory: true,
    quantity: "one",
    box: "Box",
    is_container: true
  },
  // Decoding Time to Sample Box
  stts: {
    container: "stbl",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    body: [
      ["entry_count", UInt32BE, 0]
      // For each entry these two elements:
      // ['sample_count', UInt32BE, 0], // Number of consecutive samples with same delta
      // ['sample_delta', UInt32BE, 0], // Delta of each sample
    ]
  },
  stsd: {
    container: "stbl",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: true,
    body: [
      ["entry_count", UInt32BE, 1]
      // For each entry, one of these three boxes depending on the handler:
      // VisualSampleEntry, AudioSampleEntry, HintSampleEntry
    ]
  },
  /*
  ISO/IEC 14496-12:2005(E) 8.16.2 (pp. 28)
  aligned(8) abstract class SampleEntry (unsigned int(32) format)
    extends Box(format){
    const unsigned int(8)[6] reserved = 0;
    unsigned int(16) data_reference_index;
  }
  class VisualSampleEntry(codingname) extends SampleEntry (codingname){
    unsigned int(16) pre_defined = 0;
    const unsigned int(16) reserved = 0;
    unsigned int(32)[3] pre_defined = 0;
    unsigned int(16) width;
    unsigned int(16) height;
    template unsigned int(32) horizresolution = 0x00480000; // 72 dpi
    template unsigned int(32) vertresolution = 0x00480000; // 72 dpi
    const unsigned int(32) reserved = 0;
    template unsigned int(16) frame_count = 1;
    string[32] compressorname;
    template unsigned int(16) depth = 0x0018;
    int(16) pre_defined = -1;
  }
  ISO/IEC 14496-15:2004(E) 5.3.4.1 (pp. 14)
  class AVCSampleEntry() extends VisualSampleEntry (‘avc1’){
    AVCConfigurationBox config;
    MPEG4BitRateBox (); // optional
    MPEG4ExtensionDescriptorsBox (); // optional
  }
  */
  avc1: {
    container: "stsd",
    mandatory: false,
    quantity: "one",
    box: "Box",
    is_container: true,
    body: [
      ["reserved", Empty, 6],
      ["data_reference_index", UInt16BE, 1],
      ["pre_defined", UInt16BE, 0],
      ["reserved2", Empty, 2],
      ["pre_defined2", UInt32BEArray, [0, 0, 0]],
      ["width", UInt16BE, 1920],
      ["height", UInt16BE, 1080],
      ["horizresolution", UInt32BE, 4718592],
      ["vertresolution", UInt32BE, 4718592],
      ["reserved3", UInt32BE, 0],
      ["frame_count", UInt16BE, 1],
      ["compressorname", UInt8Array, Buffer.alloc(32)],
      ["depth", UInt16BE, 24],
      ["pre_defined3", UInt16BE, 65535]
    ]
  },
  /*
  class AVCConfigurationBox extends Box(‘avcC’) {
    AVCDecoderConfigurationRecord() AVCConfig;
  }
  ISO/IEC 14496-15:2004(E) 5.2.4.1.1 (pp. 12)
  aligned(8) class AVCDecoderConfigurationRecord {
    unsigned int(8) configurationVersion = 1;
    unsigned int(8) AVCProfileIndication;
    unsigned int(8) profile_compatibility;
    unsigned int(8) AVCLevelIndication;
    bit(6) reserved = ‘111111’b;
    unsigned int(2) lengthSizeMinusOne;
    bit(3) reserved = ‘111’b;
    unsigned int(5) numOfSequenceParameterSets;
    for (i=0; i< numOfSequenceParameterSets; i++) {
      unsigned int(16) sequenceParameterSetLength ;
      bit(8*sequenceParameterSetLength) sequenceParameterSetNALUnit;
    }
    unsigned int(8) numOfPictureParameterSets;
    for (i=0; i< numOfPictureParameterSets; i++) {
      unsigned int(16) pictureParameterSetLength;
      bit(8*pictureParameterSetLength) pictureParameterSetNALUnit;
    }
  }
  */
  avcC: {
    container: "avc1",
    mandatory: false,
    quantity: "one",
    box: "Box",
    is_container: false,
    body: [
      ["configurationVersion", UInt8, 1],
      ["AVCProfileIndication", UInt8, 77],
      ["profile_compatibility", UInt8, 0],
      ["AVCLevelIndication", UInt8, 41],
      // size = reserved 0b111111 + 0b11 NALUnitLength (0b11 = 4-byte)
      ["lengthSizeMinusOne", UInt8, 255],
      // Example SPS (length 20):
      //   [0x67, 0x4d, 0x00, 0x29, 0xe2, 0x90, 0x0f, 0x00,
      //    0x44, 0xfc, 0xb8, 0x0b, 0x70, 0x10, 0x10, 0x1a,
      //    0x41, 0xe2, 0x44, 0x54]
      // number of sets = reserved 0b111 + number of SPS (0b00001 = 1)
      // ['numOfSequenceParameterSets', UInt8, 0b11100001],
      // ['sequenceParameterSetLength', UInt16BE, 0], // Lenght in bytes of the SPS that follows
      // ['sequenceParameterSetNALUnit', UInt8Array, []],
      // These are packed in a single custom element:
      ["sequenceParameterSets", createParameterSetArrayClass(224), []],
      // Example PPS (length 4):
      //   [0x68, 0xee, 0x3c, 0x80]
      // ['numOfPictureParameterSets', UInt8, 1], // number of PPS
      // ['pictureParameterSetLength', UInt16BE, 0], // Length in bytes of the PPS that follows
      // ['pictureParameterSetNALUnit', UInt8Array, []]
      // These are packed in a single custom element:
      ["pictureParameterSets", createParameterSetArrayClass(), []]
    ]
  },
  /*
  ISO/IEC 14496-12:2005(E) 8.16.2 (pp. 28)
  aligned(8) abstract class SampleEntry (unsigned int(32) format)
    extends Box(format){
    const unsigned int(8)[6] reserved = 0;
    unsigned int(16) data_reference_index;
  }
  class AudioSampleEntry(codingname) extends SampleEntry (codingname){
    const unsigned int(32)[2] reserved = 0;
    template unsigned int(16) channelcount = 2;
    template unsigned int(16) samplesize = 16;
    unsigned int(16) pre_defined = 0;
    const unsigned int(16) reserved = 0 ;
    template unsigned int(32) samplerate = {timescale of media}<<16;
  }
  */
  mp4a: {
    container: "stsd",
    mandatory: false,
    quantity: "one",
    box: "Box",
    is_container: true,
    body: [
      ["reserved", Empty, 6],
      ["data_reference_index", UInt16BE, 1],
      ["reserved2", UInt32BEArray, [0, 0]],
      ["channelcount", UInt16BE, 2],
      ["samplesize", UInt16BE, 16],
      ["pre_defined", UInt16BE, 0],
      ["reserved3", UInt16BE, 0],
      ["samplerate", UInt32BE, 0]
      // 16.16 bit floating point
    ]
  },
  /* Elementary stream descriptor
    basic box that holds only an ESDescriptor
    reference: 'https://developer.apple.com/library/content/documentation/QuickTime/
  QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-124774'
    Descriptors have a tag that identifies them, specified in ISO/IEC 14496-1 8.3.12
    ISO/IEC 14496-1 8.3.3 (pp. 24) ES_Descriptor
    aligned(8) class ES_Descriptor : bit(8) tag=ES_DescrTag {
      bit(8) length;
      bit(16) ES_ID;
      bit(1) streamDependenceFlag;
      bit(1) URL_Flag;
      const bit(1) reserved=1;
      bit(5) streamPriority;
      if (streamDependenceFlag)
        bit(16) dependsOn_ES_ID;
      if (URL_Flag)
        bit(8) URLstring[length-3-(streamDependencFlag*2)];
      ExtensionDescriptor extDescr[0 .. 255];
      LanguageDescriptor langDescr[0 .. 1];
      DecoderConfigDescriptor decConfigDescr;
      SLConfigDescriptor slConfigDescr;
      IPI_DescPointer ipiPtr[0 .. 1];
      IP_IdentificationDataSet ipIDS[0 .. 1];
      QoS_Descriptor qosDescr[0 .. 1];
    }
    aligned(8) class DecoderConfigDescriptor
      : bit(8) tag=DecoderConfigDescrTag {
      bit(8) length;
      bit(8) objectProfileIndication;
      bit(6) streamType;
      bit(1) upStream;
      const bit(1) reserved=1;
      bit(24) bufferSizeDB;
      bit(32) maxBitrate;
      bit(32) avgBitrate;
      DecoderSpecificInfo decSpecificInfo[];
    }
    aligned(8) class DecoderSpecificInfoShort extends DecoderSpecificInfo
    : bit(8) tag=DecSpecificInfoShortTag
    {
      bit(8) length;
      bit(8) specificInfo[length];
    }
    aligned(8) class SLConfigDescriptor : bit(8) tag=SLConfigDescrTag {
      bit(8) length;
      bit(8) predefined;
      if (predefined==0) {
        bit(1) useAccessUnitStartFlag;
        bit(1) useAccessUnitEndFlag;
        bit(1) useRandomAccessPointFlag;
        bit(1) usePaddingFlag;
        bit(1) useTimeStampsFlag;
        bit(1) useWallClockTimeStampFlag;
        bit(1) useIdleFlag;
        bit(1) durationFlag;
        bit(32) timeStampResolution;
        bit(32) OCRResolution;
        bit(8) timeStampLength; // must be less than 64
        bit(8) OCRLength;
        // must be less than 64
        bit(8) AU_Length;
        // must be less than 32
        bit(8) instantBitrateLength;
        bit(4) degradationPriorityLength;
        bit(4) seqNumLength;
        if (durationFlag) {
          bit(32) timeScale;
          bit(16) accessUnitDuration;
          bit(16) compositionUnitDuration;
        }
        if (!useTimeStampsFlag) {
          if (useWallClockTimeStampFlag)
            double(64) wallClockTimeStamp;
          bit(timeStampLength) startDecodingTimeStamp;
          bit(timeStampLength) startCompositionTimeStamp;
        }
      }
      aligned(8) bit(1) OCRstreamFlag;
      const bit(7) reserved=0b1111.111;
      if (OCRstreamFlag)
        bit(16) OCR_ES_Id;
    }
    */
  esds: {
    container: "mp4a",
    mandatory: false,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    body: [
      ["ES_DescrTag", UInt8, 3],
      // length of the remainder of this descriptor in byte,
      // excluding trailing embedded descriptors.
      ["ES_DescrLength", UInt8, 25],
      ["ES_ID", UInt16BE, 1],
      ["flagsAndStreamPriority", UInt8, 0],
      ["DecoderConfigDescrTag", UInt8, 4],
      // length of the remainder of this descriptor in bytes,
      // excluding trailing embedded descriptors.
      ["DecoderConfigDescrLength", UInt8, 17],
      ["objectProfileIndication", UInt8, 64],
      ["streamTypeUpstreamReserved", UInt8, 21],
      ["bufferSizeDB", UInt8Array, [0, 0, 0]],
      ["maxBitRate", UInt32BE, 0],
      ["avgBitRate", UInt32BE, 0],
      ["DecSpecificInfoShortTag", UInt8, 5],
      ["DecSpecificInfoShortLength", UInt8, 2],
      ["audioConfigBytes", UInt16BE, 0],
      ["SLConfigDescrTag", UInt8, 6],
      ["SLConfigDescrLength", UInt8, 1],
      ["SLConfigDescrPredefined", UInt8, 2]
      // ISO use
    ]
  },
  // Sample Size Box
  stsz: {
    container: "stbl",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    body: [
      ["sample_size", UInt32BE, 0],
      ["sample_count", UInt32BE, 0]
      // For each sample up to sample_count, append an entry_size:
      // ['entry_size', UInt32BE, ],
    ]
  },
  // Sample To Chunk Box
  stsc: {
    container: "stbl",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    body: [
      ["entry_count", UInt32BE, 0]
      // For each entry up to entry_count, append these elements:
      // ['first_chunk', UInt32BE, ],
      // ['samples_per_chunk', UInt32BE, ],
      // ['samples_description_index', UInt32BE, ],
    ]
  },
  // Chunk Offset Box
  stco: {
    container: "stbl",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    body: [
      ["entry_count", UInt32BE, 0]
      // For each entry up to entry_count, append an element:
      // ['chunk_offset', UInt32BE, ],
    ]
  },
  // Sync Sample Box
  stss: {
    container: "stbl",
    mandatory: false,
    quantity: "one-",
    box: "FullBox",
    is_container: false,
    body: [
      ["entry_count", UInt32BE, 0]
      // For each entry up to entry_count, append an element:
      // ['sample_number', UInt32BE, ],
    ]
  },
  // Edit Box
  edts: {
    container: "trak",
    mandatory: false,
    quantity: "one-",
    box: "Box",
    is_container: true
  },
  // Edit List Box
  elst: {
    container: "edts",
    mandatory: false,
    quantity: "one-",
    box: "FullBox",
    is_container: false,
    body: [
      ["entry_count", UInt32BE, 1],
      ["segment_duration", UInt32BE, 0],
      ["media_time", UInt32BE, 4294967295],
      ["media_rate_integer", UInt16BE, 1],
      ["media_rate_fraction", UInt16BE, 0]
    ]
  },
  mvex: {
    container: "moov",
    mandatory: false,
    quantity: "one-",
    box: "Box",
    is_container: true
  },
  mehd: {
    container: "mvex",
    mandatory: false,
    quantity: "one-",
    box: "FullBox",
    is_container: false,
    body: [
      ["fragment_duration", UInt32BE, 0]
      // Total duration of movie
    ]
  },
  trex: {
    container: "mvex",
    mandatory: true,
    quantity: "one+",
    box: "FullBox",
    is_container: false,
    body: [
      ["track_ID", UInt32BE, 1],
      // The track to which this data is applicable
      ["default_sample_description_index", UInt32BE, 1],
      ["default_sample_duration", UInt32BE, 0],
      ["default_sample_size", UInt32BE, 0],
      ["default_sample_flags", UInt32BE, 0]
    ]
  },
  moof: {
    container: "file",
    mandatory: false,
    quantity: "zero+",
    box: "Box",
    is_container: false
  },
  mfhd: {
    container: "moof",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    body: [
      ["sequence_number", UInt32BE, 0]
      // A number associated with this fragment
    ]
  },
  traf: {
    container: "moof",
    mandatory: false,
    quantity: "zero+",
    box: "Box",
    is_container: true
  },
  tfhd: {
    container: "traf",
    mandatory: true,
    quantity: "one",
    box: "FullBox",
    is_container: false,
    // Flag values for the track fragment header:
    // 0x000001 base-data-offset-present
    // 0x000002 sample-description-index-present
    // 0x000008 default-sample-duration-present
    // 0x000010 default-sample-size-present
    // 0x000020 default-sample-flags-present
    // 0x010000 duration-is-empty
    // 0x020000 default-base-is-moof
    config: {
      flags: 32
      // default sample flags present
    },
    body: [
      ["track_ID", UInt32BE, 1],
      // The track to which this data is applicable
      // ['base_data_offset', UInt64BE, 0],
      // ['default_sample_description_index', UInt32BE, 0],
      // ['default_sample_duration', UInt32BE, 0],
      // ['default_sample_size', UInt32BE, 0],
      ["default_sample_flags", UInt32BE, 0]
    ]
  },
  tfdt: {
    container: "traf",
    mandatory: false,
    quantity: "one-",
    box: "FullBox",
    is_container: false,
    config: {
      version: 1
      // Version 1 uses 64-bit value for baseMediaDecodeTime
    },
    body: [["baseMediaDecodeTime", UInt64BE, 0]]
  },
  trun: {
    container: "traf",
    mandatory: false,
    quantity: "zero+",
    box: "FullBox",
    is_container: false,
    // Flag values for the track fragment header:
    // 0x000001 data-offset-present
    // 0x000004 first-sample-flags-present
    // 0x000100 sample-duration-present
    // 0x000200 sample-size-present
    // 0x000400 sample-flags-present
    // 0x000800 sample-composition-time-offsets-present
    config: {
      flags: 773
      // default sample flags present
    },
    body: [
      ["sample_count", UInt32BE, 1],
      // How many samples there are
      ["data_offset", UInt32BE, 0],
      ["first_sample_flags", UInt32BE, 0],
      ["sample_duration", UInt32BE, 0],
      ["sample_size", UInt32BE, 0]
      // ['sample_flags', UInt32BE, 0],
      // ['sample_composition_time_offset', UInt32BE, 0],
    ]
  },
  // Unknown Box, used for parsing
  "....": {
    box: "Box",
    is_container: false,
    body: []
  },
  // File Box, special box without any headers
  file: {
    box: "None",
    is_container: true,
    mandatory: true,
    quantity: "one"
  }
};
var Header = class {
  static None() {
    return [];
  }
  static Box(type) {
    return [
      ["size", UInt32BE, 0],
      ["type", CharArray, type]
    ];
  }
  static FullBox(type) {
    return [].concat(this.Box(type), [
      ["version", UInt8, 0],
      ["flags", UInt24BE, 0]
    ]);
  }
};
var Box = class extends BoxElement {
  /**
   * Create a new Box.
   * @param  type   4-character ASCII string
   * @param  config Configuration holding (key: value) fields
   */
  constructor(type, config) {
    super(0);
    __publicField(this, "type");
    __publicField(this, "config");
    __publicField(this, "struct");
    this.type = type;
    const spec = BOXSPEC[this.type];
    if (spec === void 0) {
      throw new Error(`unknown box type: ${type}`);
    }
    this.config = Object.assign({}, spec.config, config);
    const header = Header[spec.box](this.type);
    const body = spec.body || [];
    this.struct = /* @__PURE__ */ new Map();
    let offset = 0;
    for (const [key, Type, defaultValue] of [].concat(header, body)) {
      if (this.has(key)) {
        throw new Error("Trying to add existing key");
      }
      let value = defaultValue;
      if (this.config[key]) {
        value = this.config[key];
      }
      const element = new Type(value);
      this.struct.set(key, { offset, element });
      offset += element.byteLength;
    }
    this.byteLength = offset;
  }
  /**
   * Get access to an element based on it's name.
   * @param  key The element's name
   * @return Object with 'byteLength' property and 'copy' method
   */
  element(key) {
    const value = this.struct.get(key);
    if (value === void 0) {
      throw new Error("invalid key");
    }
    return value.element;
  }
  /**
   * Set an element's value.
   * @param  key The element's name
   * @param  value The element's (new) value
   */
  set(key, value) {
    this.element(key).value = value;
  }
  /**
   * Get an element's value.
   * @param  key The element's name
   * @return The element's value
   */
  get(key) {
    return this.element(key).value;
  }
  /**
   * Get an element's offset.
   * @param  key The element's name
   * @return The element's offset
   */
  offset(key) {
    const value = this.struct.get(key);
    if (value === void 0) {
      throw new Error("invalid key");
    }
    return value.offset;
  }
  /**
   * Check if a certain element exists
   * @param  key The element's name
   * @return true if the element is known, false if not
   */
  has(key) {
    return this.struct.has(key);
  }
  /**
   * Add a new element to the box.
   * @param key     A _new_ non-existing element name.
   * @param element Something with a 'byteLength' property and 'copy' method.
   * @return this box, so that 'add' can be used in a chain
   */
  add(key, element) {
    if (this.has(key)) {
      throw new Error("Trying to add existing key");
    }
    this.struct.set(key, { offset: this.byteLength, element });
    this.byteLength += element.byteLength;
    return this;
  }
  /**
   * Create a buffer and copy all element values to it.
   * @return Data representing the box.
   */
  buffer() {
    const buffer = Buffer.allocUnsafe(this.byteLength);
    this.copy(buffer);
    return buffer;
  }
  /**
   * Copy all values of the box into an existing buffer.
   * @param  buffer     The target buffer to accept the box data
   * @param  [offset=0] The number of bytes into the target to start at.
   */
  copy(buffer, offset = 0) {
    this.set("size", this.byteLength);
    for (const entry of this.struct.values()) {
      entry.element.copy(buffer, offset + entry.offset);
    }
  }
  /**
   * Read element values from a box's data representation.
   * @param  buffer     The source buffer with box data
   * @param  [offset=0] The number of bytes into the source to start at.
   */
  load(buffer, offset = 0) {
    for (const entry of this.struct.values()) {
      if (entry.element.load !== void 0) {
        entry.element.load(buffer, offset + entry.offset);
      }
    }
  }
  /**
   * Pretty-format an entire box as an element/box hierarchy.
   * @param  [indent=0] How large an indentation to use for the hierarchy
   */
  format(indent = 0) {
    const lines = [`${" ".repeat(indent)}[${this.type}] (${this.byteLength})`];
    for (const [key, entry] of this.struct) {
      const element = entry.element;
      if (element.format !== void 0) {
        lines.push(element.format(indent + 2));
      } else {
        lines.push(
          `${" ".repeat(indent + 2)}${key} = ${element.value} (${element.byteLength})`
        );
      }
    }
    return lines.join("\n");
  }
  /**
   * Pretty-print an entire box as an element/box hierarchy.
   * @param  [indent=0] How large an indentation to use for the hierarchy
   */
  print(indent) {
    console.warn(this.format(indent));
  }
};
var Container = class _Container extends Box {
  /**
   * Create a new container box
   * @param  type   4-character ASCII string
   * @param  config Configuration holding (key: value) fields
   * @param  boxes  One or more boxes to append.
   */
  constructor(type, config, ...boxes) {
    super(type, config);
    __publicField(this, "boxSize");
    this.boxSize = 0;
    this.append(...boxes);
  }
  /**
   * Add one or more boxes to the container.
   * @param boxes The box(es) to append
   * @return this container, so that add can be used in a chain
   */
  append(...boxes) {
    for (const box of boxes) {
      this.add(`box_${this.boxSize++}`, box);
    }
    return this;
  }
  /**
   * Parse a container box by looking for boxes that it contains, and
   * recursively proceed when it is another container.
   *
   * FIXME: this cannot properly handle different versions of the FullBox,
   * currenlty the loader is hardcoded to the version used in this file.
   * Also, appearance of an esds box is assumed to be AAC audio information,
   * while the avcC box signals H.264 video information.
   *
   * @param  data The data to parse.
   */
  parse(data) {
    const tracks = [];
    while (data.byteLength > 0) {
      const type = new CharArray("....");
      type.load(data, 4);
      const boxType = type.value;
      const spec = BOXSPEC[boxType];
      let box;
      if (spec !== void 0) {
        if (spec.is_container) {
          box = new _Container(boxType);
          box.load(data);
          const boxTracks = box.parse(
            data.slice(box.byteLength, box.get("size"))
          );
          tracks.push(...boxTracks);
        } else {
          box = new Box(boxType);
          box.load(data);
          if (boxType === "avcC") {
            const profile = box.element("AVCProfileIndication").value.toString(16).padStart(2, 0);
            const compat = box.element("profile_compatibility").value.toString(16).padStart(2, 0);
            const level = box.element("AVCLevelIndication").value.toString(16).padStart(2, 0);
            tracks.push({
              type: "video",
              mime: `avc1.${profile}${compat}${level}`
            });
          } else if (boxType === "esds") {
            const audioConfigBytes = box.element("audioConfigBytes").value;
            const objectTypeIndication = audioConfigBytes >>> 11 & 31;
            tracks.push({
              type: "audio",
              mime: `mp4a.40.${objectTypeIndication}`
            });
          }
        }
      } else {
        box = new Box("....");
        box.load(data);
        box.type = box.get("type");
      }
      this.append(box);
      data = data.slice(box.get("size"));
    }
    return tracks;
  }
};

// src/components/mp4muxer/helpers/aacSettings.ts
var AUDIO_OBJECT_TYPE_NAMES = {
  1: "AAC Main",
  2: "AAC LC"
};
var FREQUENCY_VALUES = {
  0: "96 kHz",
  1: "88.2 kHz",
  2: "64 kHz",
  3: "48 kHz",
  4: "44.1 kHz",
  5: "32 kHz",
  6: "24 kHz",
  7: "22.05 kHz",
  8: "16 kHz",
  9: "12 kHz",
  10: "11.025 kHz",
  11: "8 kHz",
  12: "7.35 kHz"
};
var CHANNEL_CONFIG_NAMES = {
  1: "Mono",
  2: "Stereo"
};
var aacEncodingName = (audioConfigBytes) => {
  const audioObjectType = audioConfigBytes >>> 11 & 31;
  const frequencyIndex = audioConfigBytes >>> 7 & 15;
  const channelConfig = audioConfigBytes >>> 3 & 15;
  const audioType = AUDIO_OBJECT_TYPE_NAMES[audioObjectType] || `AAC (${audioObjectType})`;
  const samplingRate = FREQUENCY_VALUES[frequencyIndex] || "unknown";
  const channels = CHANNEL_CONFIG_NAMES[channelConfig] || channelConfig.toString();
  return {
    coding: audioType,
    samplingRate,
    channels
  };
};
var aacSettings = (media, date, trackId) => {
  const bitrate = Number(media.fmtp.parameters.bitrate) || 32e4;
  const audioConfigBytes = parseInt(media.fmtp.parameters.config, 16);
  const audioObjectType = audioConfigBytes >>> 11 & 31;
  return {
    tkhd: {
      track_ID: trackId,
      creation_time: date,
      modification_time: date,
      width: 0,
      height: 0,
      volume: 1
    },
    mdhd: {
      timescale: Number(media.rtpmap.clockrate),
      creation_time: date,
      modification_time: date,
      duration: 0
    },
    hdlr: {
      handler_type: "soun",
      name: "SoundHandler\0"
      // 00 soundhandler, add 00 if things screws up
    },
    mediaHeaderBox: new Box("smhd"),
    sampleEntryBox: new Container(
      "mp4a",
      {
        samplerate: media.rtpmap.clockrate << 16 >>> 0
        // FIXME: Is this  correct?
      },
      new Box("esds", {
        audioConfigBytes,
        // Converting from hex string to int
        maxBitRate: bitrate,
        avgBitRate: bitrate
      })
    ),
    /*
    https://wiki.multimedia.cx/index.php/Understanding_AAC
    AAC is a variable bitrate (VBR) block-based codec where each block decodes
    to 1024 time-domain samples, which means that a single block (or frame?) is
    1024 ticks long, which we take as default here.
    */
    defaultFrameDuration: 1024,
    // MIME type
    mime: `mp4a.40.${audioObjectType}`,
    codec: aacEncodingName(audioConfigBytes)
  };
};

// src/components/mp4muxer/helpers/h264Settings.ts
init_polyfill();

// src/components/mp4muxer/helpers/spsparser.ts
init_polyfill();

// src/components/mp4muxer/helpers/bufferreader.ts
init_polyfill();
var BufferReader = class {
  constructor(buffer) {
    __publicField(this, "_buffer");
    __publicField(this, "_dataView");
    __publicField(this, "_offset");
    __publicField(this, "_bitpos");
    __publicField(this, "_byte");
    this._buffer = buffer;
    this._dataView = new DataView(this._buffer);
    this._offset = 0;
    this._bitpos = 0;
    this._byte = 0;
  }
  /**
   * Reads 8-bit of data from the buffer.
   * @method readUint8
   * @param  offset - Index in the buffer.
   * @return An unsigned 8-bit integer.
   */
  readUint8(offset) {
    return this._dataView.getUint8(offset);
  }
  /**
   * Reads 16-bit of data from the buffer.
   * @method readUint16
   * @param  offset - Index in the buffer.
   * @return An unsigned 16-bit integer.
   */
  readUint16(offset) {
    return this._dataView.getUint16(offset);
  }
  /**
   * Reads 32-bit of data from the buffer.
   * @method readUint32
   * @param  offset - Index in the buffer.
   * @return An unsigned 32-bit integer.
   */
  readUint32(offset) {
    return this._dataView.getUint32(offset);
  }
  /**
   * Reads the next byte of data from the buffer and increaments the offset.
   * @method readNext
   * @return {Number} An unsigned 8-bit integer.
   */
  readNext() {
    const value = this.readUint8(this._offset);
    this._offset += 1;
    return value;
  }
  readBits(length) {
    if (length > 32 || length === 0) {
      throw new Error("length has to be between 0 - 31 bits");
    }
    let result = 0;
    for (let i = 1; i <= length; ++i) {
      if (this._bitpos === 0) {
        this._byte = this.readNext();
      }
      result = result << 1 | this._byte >> 8 - ++this._bitpos & 1;
      this._bitpos %= 8;
    }
    return result;
  }
  readUnsignedExpGolomb() {
    let bitsToRead = 0;
    while (this.readBits(1) !== 1) {
      bitsToRead++;
    }
    if (bitsToRead === 0) {
      return 0;
    }
    if (bitsToRead >= 31) {
      throw new Error("read unsigned exponential Golomb: internal error");
    }
    let n = this.readBits(bitsToRead);
    n |= 1 << bitsToRead;
    return n - 1;
  }
  readSignedExpGolomb() {
    let r = this.readUnsignedExpGolomb();
    if (r & 1) {
      r = r + 1 >> 1;
    } else {
      r = -(r >> 1);
    }
    return r;
  }
  /**
   * Returns the size of the buffer
   * @method readSize
   * @return {Number} The buffer size.
   */
  size() {
    return this._buffer.byteLength;
  }
  /**
   * Returns an instance of the buffer as an unsigned 8-bit integer array.
   * @method getUint8Array
   * @return {Uint8Array} Unsigned 8-bit integer representation of the buffer
   */
  getUint8Array() {
    return new Uint8Array(this._buffer);
  }
  /**
   * Returns the buffer object
   * @method getArrayBuffer
   * @return {ArrayBuffer} The buffer used the BufferReader
   */
  getArrayBuffer() {
    return this._buffer;
  }
};

// src/components/mp4muxer/helpers/spsparser.ts
var SPSParser = class {
  constructor(buffer) {
    __publicField(this, "reader");
    this.reader = new BufferReader(buffer);
  }
  parse() {
    this.reader.readNext();
    const profile = this.reader.readNext();
    this.reader.readNext();
    const level = this.reader.readNext();
    this.reader.readUnsignedExpGolomb();
    if ([100, 110, 122, 244, 44, 83, 86, 118].includes(profile)) {
      const chromaFormat = this.reader.readUnsignedExpGolomb();
      if (chromaFormat === 3) {
        this.reader.readBits(1);
      }
      this.reader.readUnsignedExpGolomb();
      this.reader.readUnsignedExpGolomb();
      this.reader.readBits(1);
      const seqScalingMatrix = this.reader.readBits(1);
      if (seqScalingMatrix) {
        for (let k = 0; k < (chromaFormat !== 3 ? 8 : 12); k++) {
          this.reader.readBits(1);
        }
      }
    }
    this.reader.readUnsignedExpGolomb();
    const picOrderCntType = this.reader.readUnsignedExpGolomb();
    if (picOrderCntType === 0) {
      this.reader.readUnsignedExpGolomb();
    } else if (picOrderCntType === 1) {
      let numRefFramesInPic = 0;
      this.reader.readBits(1);
      this.reader.readSignedExpGolomb();
      this.reader.readSignedExpGolomb();
      numRefFramesInPic = this.reader.readUnsignedExpGolomb();
      for (let i = 0; i < numRefFramesInPic; i++) {
        this.reader.readSignedExpGolomb();
      }
    }
    this.reader.readUnsignedExpGolomb();
    this.reader.readBits(1);
    const picWidthInMbsMinus1 = this.reader.readUnsignedExpGolomb();
    const picHeightInMapUnitsMinus1 = this.reader.readUnsignedExpGolomb();
    const picFrameMbsOnlyFlag = this.reader.readBits(1);
    this.reader.readBits(1);
    const frameCroppingFlag = this.reader.readBits(1);
    const frameCropLeftOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
    const frameCropRightOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
    const frameCropTopOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
    const frameCropBottomOffset = frameCroppingFlag ? this.reader.readUnsignedExpGolomb() : 0;
    const w = (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2;
    const h = (2 - picFrameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2;
    return {
      profile,
      level: level / 10,
      width: w,
      height: h
    };
  }
};

// src/components/mp4muxer/helpers/utils.ts
init_polyfill();
function b64ToUint6(nChr) {
  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
}
function base64DecToArr(sBase64, nBlocksSize) {
  const sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, "");
  const nInLen = sB64Enc.length;
  const nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2;
  const taBytes = new Uint8Array(nOutLen);
  let nMod3;
  let nMod4;
  let nUint24 = 0;
  let nOutIdx = 0;
  for (let nInIdx = 0; nInIdx < nInLen; nInIdx++) {
    nMod4 = nInIdx & 3;
    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
    if (nMod4 === 3 || nInLen - nInIdx === 1) {
      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
      }
      nUint24 = 0;
    }
  }
  return taBytes;
}

// src/components/mp4muxer/helpers/h264Settings.ts
var PROFILE_NAMES = {
  66: "Baseline",
  77: "Main",
  100: "High"
};
var h264EncodingName = (profileLevelId) => {
  const profileCode = parseInt(profileLevelId.substr(0, 2), 16);
  const levelCode = parseInt(profileLevelId.substr(4, 2), 16);
  const profile = PROFILE_NAMES[profileCode] || profileCode.toString();
  const level = (levelCode / 10).toFixed(1);
  return {
    coding: "H.264",
    profile,
    level
  };
};
var h264Settings = (media, date, trackId) => {
  const profileLevelId = media.fmtp.parameters["profile-level-id"];
  const parameterSets = media.fmtp.parameters["sprop-parameter-sets"].split(",").map(base64DecToArr);
  const sps = parameterSets.slice(0, 1);
  const pps = parameterSets.slice(1);
  const parsedSps = new SPSParser(sps[0].buffer).parse();
  const FALLBACK_FRAME_DURATION = 3600;
  return {
    mediaHeaderBox: new Box("vmhd"),
    sampleEntryBox: new Container(
      "avc1",
      {
        width: parsedSps.width,
        height: parsedSps.height
      },
      new Box("avcC", {
        AVCProfileIndication: sps[0][1],
        profile_compatibility: sps[0][2],
        AVCLevelIndication: sps[0][3],
        sequenceParameterSets: sps,
        pictureParameterSets: pps
      })
    ),
    tkhd: {
      track_ID: trackId,
      creation_time: date,
      modification_time: date,
      width: parsedSps.width << 16,
      height: parsedSps.height << 16,
      volume: 0
    },
    hdlr: {},
    mdhd: {
      timescale: media.rtpmap.clockrate,
      creation_time: date,
      modification_time: date,
      duration: 0
    },
    // (ticks / s) / (frames / s) = ticks / frame, e.g. frame duration in ticks
    defaultFrameDuration: media.framerate !== void 0 && media.framerate > 0 ? Number(media.rtpmap.clockrate) / Number(media.framerate) || FALLBACK_FRAME_DURATION : FALLBACK_FRAME_DURATION,
    // MIME type
    mime: `avc1.${profileLevelId}`,
    codec: h264EncodingName(profileLevelId)
  };
};

// src/components/mp4muxer/helpers/boxbuilder.ts
var formatDefaults = {
  "MPEG4-GENERIC": aacSettings,
  H264: h264Settings
};
var createTrackData = () => {
  return {
    lastTimestamp: 0,
    baseMediaDecodeTime: 0,
    defaultFrameDuration: 0,
    clockrate: 0,
    bitrate: 0,
    framerate: 0,
    cumulativeByteLength: 0,
    cumulativeDuration: 0,
    cumulativeFrames: 0
  };
};
var updateRateInfo = (trackData, { byteLength, duration }) => {
  trackData.cumulativeByteLength += byteLength;
  trackData.cumulativeDuration += duration;
  trackData.cumulativeFrames++;
  if (trackData.cumulativeDuration >= trackData.clockrate) {
    const bits = 8 * trackData.cumulativeByteLength;
    const frames = trackData.cumulativeFrames;
    const seconds = trackData.cumulativeDuration / trackData.clockrate;
    trackData.bitrate = bits / seconds;
    trackData.framerate = frames / seconds;
    trackData.cumulativeByteLength = 0;
    trackData.cumulativeDuration = 0;
    trackData.cumulativeFrames = 0;
  }
};
var BoxBuilder = class {
  constructor() {
    __publicField(this, "trackIdMap");
    __publicField(this, "sequenceNumber");
    __publicField(this, "ntpPresentationTime");
    __publicField(this, "trackData");
    __publicField(this, "videoTrackId");
    this.trackIdMap = {};
    this.sequenceNumber = 0;
    this.ntpPresentationTime = 0;
    this.trackData = [];
  }
  trak(settings) {
    const trak = new Container("trak");
    const mdia = new Container("mdia");
    const minf = new Container("minf");
    const dinf = new Container("dinf");
    const dref = new Container("dref");
    const stbl = new Container("stbl");
    dref.set("entry_count", 1);
    trak.append(
      new Box("tkhd", settings.tkhd),
      mdia.append(
        new Box("mdhd", settings.mdhd),
        new Box("hdlr", settings.hdlr),
        minf.append(
          settings.mediaHeaderBox,
          // vmhd or smhd box (video or sound)
          dinf.append(dref.append(new Box("url "))),
          stbl.append(
            new Container("stsd", void 0, settings.sampleEntryBox),
            new Box("stts"),
            new Box("stsc"),
            new Box("stco"),
            new Box("stsz"),
            new Box("stss")
          )
        )
      )
    );
    return trak;
  }
  /**
   * Creates a Moov box from the provided options.
   * @method moov
   * @param  sdp - The session description protocol
   * @param  date - The creation/modification time of the movie
   * @return Moov object
   */
  moov(sdp, date) {
    const moov = new Container("moov");
    moov.append(
      new Box("mvhd", {
        creation_time: date,
        modification_time: date,
        duration: 0
      })
    );
    const mvex = new Container("mvex");
    this.trackIdMap = {};
    this.sequenceNumber = 0;
    this.ntpPresentationTime = 0;
    let trackId = 0;
    this.trackData = [];
    sdp.media.forEach((media) => {
      if (media.rtpmap === void 0) {
        return;
      }
      const payloadType2 = media.rtpmap.payloadType;
      const encoding = media.rtpmap.encodingName;
      if (formatDefaults[encoding] !== void 0) {
        this.trackIdMap[payloadType2] = ++trackId;
        if (media.type.toLowerCase() === "video") {
          this.videoTrackId = trackId;
        }
        const settings = formatDefaults[encoding](media, date, trackId);
        media.mime = settings.mime;
        media.codec = settings.codec;
        const trackData = createTrackData();
        trackData.clockrate = media.rtpmap.clockrate;
        trackData.defaultFrameDuration = settings.defaultFrameDuration;
        this.trackData.push(trackData);
        const trak = this.trak(settings);
        moov.append(trak);
        mvex.append(new Box("trex", { track_ID: trackId }));
      }
    });
    moov.append(mvex);
    return moov;
  }
  /**
   * Boxes that carry actual elementary stream fragment metadata + data.
   */
  /**
   * Creates a moof box from the provided fragment metadata.
   * @method moof
   * @param  metadata - Track ID, timestamp, bytelength
   * @return moof Container
   */
  moof(metadata) {
    const { trackId, timestamp: timestamp2, byteLength } = metadata;
    const trackOffset = trackId - 1;
    const trackData = this.trackData[trackOffset];
    const duration = trackData.lastTimestamp !== 0 ? timestamp2 - trackData.lastTimestamp | 0 : trackData.defaultFrameDuration;
    trackData.lastTimestamp = timestamp2;
    const moof = new Container("moof");
    const traf = new Container("traf");
    const trun = new Box("trun", {
      sample_duration: duration,
      sample_size: byteLength,
      first_sample_flags: 64
    });
    moof.append(
      new Box("mfhd", { sequence_number: this.sequenceNumber++ }),
      traf.append(
        new Box("tfhd", { track_ID: trackId }),
        new Box("tfdt", { baseMediaDecodeTime: trackData.baseMediaDecodeTime }),
        trun
      )
    );
    trackData.baseMediaDecodeTime += duration;
    trun.set("data_offset", moof.byteLength + 8);
    updateRateInfo(trackData, { byteLength, duration });
    return moof;
  }
  /**
   * Creates an mdat box containing the elementary stream data.
   * @param  data - Elementary stream data
   * @return mdat Box
   */
  mdat(data) {
    const box = new Box("mdat");
    box.add("data", data);
    return box;
  }
  setPresentationTime(trackId, ntpTimestamp) {
    if (!this.ntpPresentationTime && ntpTimestamp && trackId === this.videoTrackId) {
      const trackOffset = trackId - 1;
      const trackData = this.trackData[trackOffset];
      this.ntpPresentationTime = ntpTimestamp - 1e3 * (trackData.baseMediaDecodeTime / trackData.clockrate);
    }
  }
};

// src/components/mp4muxer/index.ts
var Mp4Muxer = class extends Tube {
  /**
   * Create a new mp4muxer component.
   * @return {undefined}
   */
  constructor() {
    const boxBuilder = new BoxBuilder();
    const onSync = (ntpPresentationTime) => {
      this.onSync && this.onSync(ntpPresentationTime);
    };
    const incoming = new import_stream10.Transform({
      objectMode: true,
      transform(msg, encoding, callback) {
        if (msg.type === 5 /* SDP */) {
          const now = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3 + 2082852e3);
          const ftyp = new Box("ftyp");
          const moov = boxBuilder.moov(msg.sdp, now);
          const data = Buffer.allocUnsafe(ftyp.byteLength + moov.byteLength);
          ftyp.copy(data, 0);
          moov.copy(data, ftyp.byteLength);
          (0, import_debug4.default)("msl:mp4:isom")(`ftyp: ${ftyp.format()}`);
          (0, import_debug4.default)("msl:mp4:isom")(`moov: ${moov.format()}`);
          const tracks = msg.sdp.media.map((media) => {
            return {
              type: media.type,
              encoding: media.rtpmap && media.rtpmap.encodingName,
              mime: media.mime,
              codec: media.codec
            };
          });
          this.push({ type: 8 /* ISOM */, data, tracks, ftyp, moov });
        } else if (msg.type === 6 /* ELEMENTARY */ || msg.type === 7 /* H264 */) {
          const { payloadType: payloadType2, timestamp: timestamp2, ntpTimestamp } = msg;
          const trackId = boxBuilder.trackIdMap[payloadType2];
          if (trackId) {
            if (!boxBuilder.ntpPresentationTime) {
              boxBuilder.setPresentationTime(trackId, ntpTimestamp);
              if (boxBuilder.ntpPresentationTime) {
                onSync(boxBuilder.ntpPresentationTime);
              }
            }
            let checkpointTime;
            const idrPicture = msg.type === 7 /* H264 */ ? msg.nalType === 5 /* IDR_PICTURE */ : void 0;
            if (boxBuilder.ntpPresentationTime && idrPicture && msg.ntpTimestamp !== void 0) {
              checkpointTime = (msg.ntpTimestamp - boxBuilder.ntpPresentationTime) / 1e3;
            }
            const byteLength = msg.data.byteLength;
            const moof = boxBuilder.moof({ trackId, timestamp: timestamp2, byteLength });
            const mdat = boxBuilder.mdat(msg.data);
            const data = Buffer.allocUnsafe(moof.byteLength + mdat.byteLength);
            moof.copy(data, 0);
            mdat.copy(data, moof.byteLength);
            this.push({
              type: 8 /* ISOM */,
              data,
              moof,
              mdat,
              ntpTimestamp,
              checkpointTime
            });
          }
        } else {
          this.push(msg);
        }
        callback();
      }
    });
    super(incoming);
    __publicField(this, "boxBuilder");
    __publicField(this, "onSync");
    this.boxBuilder = boxBuilder;
  }
  get bitrate() {
    return this.boxBuilder.trackData && this.boxBuilder.trackData.map((data) => data.bitrate);
  }
  get framerate() {
    return this.boxBuilder.trackData && this.boxBuilder.trackData.map((data) => data.framerate);
  }
  get ntpPresentationTime() {
    return this.boxBuilder.ntpPresentationTime;
  }
};

// src/components/mse/index.ts
init_polyfill();
var import_debug5 = __toESM(require("debug"));
var import_stream11 = __toESM(require_stream_browserify());

// src/utils/protocols/rtcp.ts
init_polyfill();
var RTCPPacketType = /* @__PURE__ */ ((RTCPPacketType2) => {
  RTCPPacketType2[RTCPPacketType2["SR"] = 200] = "SR";
  RTCPPacketType2[RTCPPacketType2["RR"] = 201] = "RR";
  RTCPPacketType2[RTCPPacketType2["SDES"] = 202] = "SDES";
  RTCPPacketType2[RTCPPacketType2["BYE"] = 203] = "BYE";
  RTCPPacketType2[RTCPPacketType2["APP"] = 204] = "APP";
  return RTCPPacketType2;
})(RTCPPacketType || {});
var parseBase = (buffer) => ({
  version: buffer[0] >>> 6,
  padding: !!(buffer[0] & POS[2]),
  count: buffer[0] & 31,
  packetType: buffer.readUInt8(1),
  length: buffer.readUInt16BE(2)
});
var parseRtcp = (buffer) => {
  const base = parseBase(buffer);
  switch (base.packetType) {
    case 200 /* SR */:
      return parseSR(buffer, base);
    case 201 /* RR */:
      return parseRR(buffer, base);
    case 202 /* SDES */:
      return parseSDES(buffer, base);
    case 203 /* BYE */:
      return parseBYE(buffer, base);
    case 204 /* APP */:
      return parseAPP(buffer, base);
    default:
      return base;
  }
};
var rtcpMessageFromBuffer = (channel, buffer) => {
  return {
    type: 3 /* RTCP */,
    data: buffer,
    channel,
    rtcp: parseRtcp(buffer)
  };
};
var SR = {
  packetType: 200
};
var parseReportBlocks = (count, buffer, offset) => {
  const reports = [];
  for (let reportNumber = 0; reportNumber < count; reportNumber++) {
    const o = offset + reportNumber * 24;
    reports.push({
      syncSource: buffer.readUInt32BE(o + 0),
      fractionLost: buffer.readUInt8(o + 4),
      cumulativeNumberOfPacketsLost: buffer.readUIntBE(o + 5, 3),
      extendedHighestSequenceNumberReceived: buffer.readUInt32BE(o + 8),
      interarrivalJitter: buffer.readUInt32BE(o + 12),
      lastSRTimestamp: buffer.readUInt32BE(o + 16),
      delaySinceLastSR: buffer.readUInt32BE(o + 20)
    });
  }
  return reports;
};
var parseSR = (buffer, base) => __spreadProps(__spreadValues({}, base), {
  syncSource: buffer.readUInt32BE(4),
  ntpMost: buffer.readUInt32BE(8),
  ntpLeast: buffer.readUInt32BE(12),
  rtpTimestamp: buffer.readUInt32BE(16),
  sendersPacketCount: buffer.readUInt32BE(20),
  sendersOctetCount: buffer.readUInt32BE(24),
  reports: parseReportBlocks(base.count, buffer, 28)
});
var isRtcpSR = (rtcp) => rtcp.packetType === 200 /* SR */;
var parseRR = (buffer, base) => __spreadProps(__spreadValues({}, base), {
  syncSource: buffer.readUInt32BE(4),
  reports: parseReportBlocks(base.count, buffer, 8)
});
var isRtcpRR = (rtcp) => rtcp.packetType === 201 /* RR */;
var SDESItem = /* @__PURE__ */ ((SDESItem2) => {
  SDESItem2[SDESItem2["CNAME"] = 1] = "CNAME";
  SDESItem2[SDESItem2["NAME"] = 2] = "NAME";
  SDESItem2[SDESItem2["EMAIL"] = 3] = "EMAIL";
  SDESItem2[SDESItem2["PHONE"] = 4] = "PHONE";
  SDESItem2[SDESItem2["LOC"] = 5] = "LOC";
  SDESItem2[SDESItem2["TOOL"] = 6] = "TOOL";
  SDESItem2[SDESItem2["NOTE"] = 7] = "NOTE";
  SDESItem2[SDESItem2["PRIV"] = 8] = "PRIV";
  return SDESItem2;
})(SDESItem || {});
var parseSDES = (buffer, base) => {
  const sourceDescriptions = [];
  let offset = 4;
  for (let block = 0; block < base.count; block++) {
    const chunk = {
      source: buffer.readUInt32BE(offset),
      items: []
    };
    offset += 4;
    while (true) {
      const itemType = buffer.readUInt8(offset++);
      if (itemType === 0) {
        if (offset % 4 !== 0) {
          offset += 4 - offset % 4;
        }
        break;
      }
      const length = buffer.readUInt8(offset++);
      if (itemType === 8 /* PRIV */) {
        const prefixLength = buffer.readUInt8(offset);
        const prefix = buffer.toString(
          "utf8",
          offset + 1,
          offset + 1 + prefixLength
        );
        const value = buffer.toString(
          "utf8",
          offset + 1 + prefixLength,
          offset + length
        );
        chunk.items.push([8 /* PRIV */, prefix, value]);
      } else {
        const value = buffer.toString("utf8", offset, offset + length);
        chunk.items.push([itemType, value]);
      }
      offset += length;
    }
    sourceDescriptions.push(chunk);
  }
  return __spreadProps(__spreadValues({}, base), {
    syncSource: buffer.readUInt32BE(4),
    sourceDescriptions
  });
};
var isRtcpSDES = (rtcp) => rtcp.packetType === 202 /* SDES */;
var parseBYE = (buffer, base) => {
  const sources = [];
  for (let block = 0; block < base.count; block++) {
    sources.push(buffer.readUInt32BE(4 + 4 * block));
  }
  let reason;
  if (base.length > base.count) {
    const start = 4 + 4 * base.count;
    const length = buffer.readUInt8(start);
    reason = buffer.toString("utf-8", start + 1, start + 1 + length);
  }
  return __spreadProps(__spreadValues({}, base), {
    sources,
    reason
  });
};
var isRtcpBye = (rtcp) => rtcp.packetType === 203 /* BYE */;
var parseAPP = (buffer, base) => {
  return __spreadProps(__spreadValues({}, base), {
    subtype: base.count,
    source: buffer.readUInt32BE(4),
    name: buffer.toString("ascii", 8, 12),
    data: buffer.slice(12)
  });
};
var isRtcpApp = (rtcp) => rtcp.packetType === 204 /* APP */;

// src/components/mse/index.ts
var TRIGGER_THRESHOLD = 100;
var debug5 = (0, import_debug5.default)("msl:mse");
var MseSink = class extends Sink {
  /**
   * Create a Media component.
   *
   * The constructor sets up two streams and connects them to the MediaSource.
   *
   * @param el - A video element to connect the media source to
   */
  constructor(el) {
    if (el === void 0) {
      throw new Error("video element argument missing");
    }
    let mse;
    let sourceBuffer;
    const incoming = new import_stream11.Writable({
      objectMode: true,
      write: (msg, _, callback) => {
        var _a, _b;
        if (msg.type === 8 /* ISOM */) {
          this._done = callback;
          if (msg.tracks !== void 0 || msg.mime !== void 0) {
            const tracks = (_a = msg.tracks) != null ? _a : [];
            const mimeCodecs = tracks.map((track) => track.mime).filter((mime) => mime);
            const codecs = mimeCodecs.length !== 0 ? mimeCodecs.join(", ") : "avc1.640029, mp4a.40.2";
            const mimeType = (_b = msg.mime) != null ? _b : `video/mp4; codecs="${codecs}"`;
            if (!MediaSource.isTypeSupported(mimeType)) {
              incoming.emit("error", `unsupported media type: ${mimeType}`);
              return;
            }
            this._lastCheckpointTime = 0;
            mse = new MediaSource();
            el.src = window.URL.createObjectURL(mse);
            const handler = () => {
              if (mse === void 0) {
                incoming.emit("error", "no MediaSource instance");
                return;
              }
              window.URL.revokeObjectURL(el.src);
              mse.removeEventListener("sourceopen", handler);
              this.onSourceOpen && this.onSourceOpen(mse, tracks);
              sourceBuffer = this.addSourceBuffer(el, mse, mimeType);
              sourceBuffer.onerror = (e) => {
                console.error("error on SourceBuffer: ", e);
                incoming.emit("error");
              };
              try {
                sourceBuffer.appendBuffer(msg.data);
              } catch (err) {
                debug5("failed to append to SourceBuffer: ", err, msg);
              }
            };
            mse.addEventListener("sourceopen", handler);
          } else {
            this._lastCheckpointTime = msg.checkpointTime !== void 0 ? msg.checkpointTime : this._lastCheckpointTime;
            try {
              sourceBuffer == null ? void 0 : sourceBuffer.appendBuffer(msg.data);
            } catch (e) {
              debug5("failed to append to SourceBuffer: ", e, msg);
            }
          }
        } else if (msg.type === 3 /* RTCP */) {
          if (isRtcpBye(msg.rtcp)) {
            (mse == null ? void 0 : mse.readyState) === "open" && mse.endOfStream();
          }
          callback();
        } else {
          callback();
        }
      }
    });
    incoming.on("finish", () => {
      console.warn("incoming stream finished: end stream");
      mse && mse.readyState === "open" && mse.endOfStream();
    });
    incoming.on("error", (msg) => {
      console.error("error on incoming stream: ", msg);
      if (sourceBuffer && sourceBuffer.updating) {
        sourceBuffer.addEventListener("updateend", () => {
          (mse == null ? void 0 : mse.readyState) === "open" && mse.endOfStream();
        });
      } else {
        (mse == null ? void 0 : mse.readyState) === "open" && mse.endOfStream();
      }
    });
    const outgoing = new import_stream11.Readable({
      objectMode: true,
      read() {
      }
    });
    outgoing.on("error", () => {
      console.warn("outgoing stream broke somewhere");
    });
    super(incoming, outgoing);
    __publicField(this, "_videoEl");
    __publicField(this, "_done");
    __publicField(this, "_lastCheckpointTime");
    __publicField(this, "onSourceOpen");
    this._videoEl = el;
    this._lastCheckpointTime = 0;
  }
  /**
   * Add a new sourceBuffer to the mediaSource and remove old ones.
   * @param el - The media element holding the media source.
   * @param mse - The media source the buffer should be attached to.
   * @param mimeType - MIME type and codecs, e.g.: 'video/mp4; codecs="avc1.4D0029, mp4a.40.2"'
   */
  addSourceBuffer(el, mse, mimeType) {
    const sourceBuffer = mse.addSourceBuffer(mimeType);
    let trigger = 0;
    const onUpdateEndHandler = () => {
      ;
      ++trigger;
      if (trigger > TRIGGER_THRESHOLD && sourceBuffer.buffered.length) {
        trigger = 0;
        const index = sourceBuffer.buffered.length - 1;
        const start = sourceBuffer.buffered.start(index);
        const end = Math.min(el.currentTime, this._lastCheckpointTime) - 10;
        try {
          if (end > start) {
            sourceBuffer.remove(start, end);
            return;
          }
        } catch (e) {
          console.warn(e);
        }
      }
      this._done && this._done();
    };
    sourceBuffer.addEventListener("updateend", onUpdateEndHandler);
    return sourceBuffer;
  }
  get currentTime() {
    return this._videoEl.currentTime;
  }
  play() {
    return __async(this, null, function* () {
      return yield this._videoEl.play();
    });
  }
  pause() {
    return this._videoEl.pause();
  }
};

// src/components/onvifdepay/index.ts
init_polyfill();
var import_stream12 = __toESM(require_stream_browserify());
var ONVIFDepay = class extends Tube {
  constructor() {
    let XMLPayloadType;
    let packets = [];
    const incoming = new import_stream12.Transform({
      objectMode: true,
      transform(msg, encoding, callback) {
        if (msg.type === 5 /* SDP */) {
          let validMedia;
          for (const media of msg.sdp.media) {
            if (media.type === "application" && media.rtpmap && media.rtpmap.encodingName === "VND.ONVIF.METADATA") {
              validMedia = media;
            }
          }
          if (validMedia && validMedia.rtpmap) {
            XMLPayloadType = Number(validMedia.rtpmap.payloadType);
          }
          callback(void 0, msg);
        } else if (msg.type === 2 /* RTP */ && payloadType(msg.data) === XMLPayloadType) {
          packets.push(payload(msg.data));
          if (marker(msg.data) && packets.length > 0) {
            const xmlMsg = {
              timestamp: timestamp(msg.data),
              ntpTimestamp: msg.ntpTimestamp,
              payloadType: payloadType(msg.data),
              data: Buffer.concat(packets),
              type: 9 /* XML */
            };
            callback(void 0, xmlMsg);
            packets = [];
            return;
          }
          callback();
        } else {
          callback(void 0, msg);
        }
      }
    });
    super(incoming);
  }
};

// src/components/rtsp-parser/index.ts
init_polyfill();
var import_stream13 = __toESM(require_stream_browserify());

// src/components/rtsp-parser/builder.ts
init_polyfill();
var import_debug6 = __toESM(require("debug"));
var DEFAULT_PROTOCOL = "RTSP/1.0";
var builder = (msg) => {
  if (!msg.method || !msg.uri) {
    throw new Error("message needs to contain a method and a uri");
  }
  const protocol = msg.protocol || DEFAULT_PROTOCOL;
  const headers = msg.headers || {};
  const messageString = [
    `${msg.method} ${msg.uri} ${protocol}`,
    Object.entries(headers).map(([key, value]) => `${key}: ${value}`).join("\r\n"),
    "\r\n"
  ].join("\r\n");
  (0, import_debug6.default)("msl:rtsp:outgoing")(messageString);
  return Buffer.from(messageString);
};

// src/components/rtsp-parser/parser.ts
init_polyfill();

// src/utils/protocols/rtsp.ts
init_polyfill();
var extractHeaderValue = (buffer, header) => {
  const anchor = `
${header.toLowerCase()}: `;
  const start = buffer.toString().toLowerCase().indexOf(anchor);
  if (start >= 0) {
    const end = buffer.indexOf("\n", start + anchor.length);
    const headerValue = buffer.toString("ascii", start + anchor.length, end).trim();
    return headerValue;
  }
  return null;
};
var sequence = (buffer) => {
  const val = extractHeaderValue(buffer, "CSeq");
  if (val !== null) {
    return Number(val);
  }
  return null;
};
var sessionId = (buffer) => {
  const val = extractHeaderValue(buffer, "Session");
  return val ? val.split(";")[0] : null;
};
var sessionTimeout = (buffer) => {
  const val = extractHeaderValue(buffer, "Session");
  if (val === null) {
    return null;
  }
  const defaultTimeout = 60;
  const timeoutToken = "timeout=";
  const timeoutPosition = val.toLowerCase().indexOf(timeoutToken);
  if (timeoutPosition !== -1) {
    let timeoutVal = val.substring(timeoutPosition + timeoutToken.length);
    timeoutVal = timeoutVal.split(";")[0];
    const parsedTimeout = parseInt(timeoutVal);
    return isNaN(parsedTimeout) ? defaultTimeout : parsedTimeout;
  }
  return defaultTimeout;
};
var statusCode = (buffer) => {
  return Number(buffer.toString("ascii", 9, 12));
};
var contentBase = (buffer) => {
  return extractHeaderValue(buffer, "Content-Base");
};
var contentLocation = (buffer) => {
  return extractHeaderValue(buffer, "Content-Location");
};
var connectionEnded = (buffer) => {
  const connectionToken = extractHeaderValue(buffer, "Connection");
  return connectionToken !== null && connectionToken.toLowerCase() === "close";
};
var range = (buffer) => {
  const npt = extractHeaderValue(buffer, "Range");
  if (npt !== null) {
    return npt.split("=")[1].split("-");
  }
  return void 0;
};
var bodyOffset = (chunk) => {
  const bodyOffsets = ["\n\n", "\r\r", "\r\n\r\n"].map((s) => {
    const offset = chunk.indexOf(s);
    if (offset !== -1) {
      return offset + s.length;
    }
    return offset;
  }).filter((offset) => offset !== -1);
  if (bodyOffsets.length > 0) {
    return bodyOffsets.reduce((acc, offset) => {
      return Math.min(acc, offset);
    });
  }
  return -1;
};

// src/utils/protocols/sdp.ts
init_polyfill();
var extractLineVals = (buffer, lineStart, start = 0) => {
  const anchor = `
${lineStart}`;
  start = buffer.indexOf(anchor, start);
  let end = 0;
  const ret = [];
  while (start >= 0) {
    end = buffer.indexOf("\n", start + anchor.length);
    ret.push(buffer.toString("ascii", start + anchor.length, end).trim());
    start = buffer.indexOf(anchor, end);
  }
  return ret;
};
var newMediaLevel = (line) => {
  return line.match(/^m=/);
};
var splitOnFirst = (c, text) => {
  const p = text.indexOf(c);
  if (p < 0) {
    return [text.slice(0)];
  }
  return [text.slice(0, p), text.slice(p + 1)];
};
var attributeParsers = {
  fmtp: (value) => {
    const [format, stringParameters] = splitOnFirst(" ", value);
    switch (format) {
      default: {
        const pairs = stringParameters.trim().split(";");
        const parameters = {};
        pairs.forEach((pair) => {
          const [key, val] = splitOnFirst("=", pair);
          const normalizedKey = key.trim().toLowerCase();
          if (normalizedKey !== "") {
            parameters[normalizedKey] = val.trim();
          }
        });
        return { format, parameters };
      }
    }
  },
  framerate: Number,
  rtpmap: (value) => {
    const [payloadType2, encoding] = splitOnFirst(" ", value);
    const [encodingName, clockrate, encodingParameters] = encoding.toUpperCase().split("/");
    if (encodingParameters === void 0) {
      return {
        payloadType: Number(payloadType2),
        encodingName,
        clockrate: Number(clockrate)
      };
    }
    return {
      payloadType: Number(payloadType2),
      encodingName,
      clockrate: Number(clockrate),
      encodingParameters
    };
  },
  transform: (value) => {
    return value.split(";").map((row) => row.split(",").map(Number));
  },
  "x-sensor-transform": (value) => {
    return value.split(";").map((row) => row.split(",").map(Number));
  },
  framesize: (value) => {
    return value.split(" ")[1].split("-").map(Number);
  }
};
var parseAttribute = (body) => {
  const [attribute, value] = splitOnFirst(":", body);
  if (value === void 0) {
    return { [attribute]: true };
  }
  if (attributeParsers[attribute] !== void 0) {
    return { [attribute]: attributeParsers[attribute](value) };
  }
  return { [attribute]: value };
};
var extractField = (line) => {
  const prefix = line.slice(0, 1);
  const body = line.slice(2);
  switch (prefix) {
    case "v":
      return { version: body };
    case "o": {
      const [
        username,
        sessionId2,
        sessionVersion,
        netType,
        addrType,
        unicastAddress
      ] = body.split(" ");
      return {
        origin: {
          addrType,
          netType,
          sessionId: sessionId2,
          sessionVersion,
          unicastAddress,
          username
        }
      };
    }
    case "s":
      return { sessionName: body };
    case "i":
      return { sessionInformation: body };
    case "u":
      return { uri: body };
    case "e":
      return { email: body };
    case "p":
      return { phone: body };
    case "c": {
      const [connectionNetType, connectionAddrType, connectionAddress] = body.split(" ");
      return {
        connectionData: {
          addrType: connectionAddrType,
          connectionAddress,
          netType: connectionNetType
        }
      };
    }
    case "b": {
      const [bwtype, bandwidth] = body.split(":");
      return { bwtype, bandwidth };
    }
    case "t": {
      const [startTime, stopTime] = body.split(" ").map(Number);
      return { time: { startTime, stopTime } };
    }
    case "r": {
      const [repeatInterval, activeDuration, ...offsets] = body.split(" ").map(Number);
      return {
        repeatTimes: { repeatInterval, activeDuration, offsets }
      };
    }
    case "z":
      return;
    case "k":
      return;
    case "a":
      return parseAttribute(body);
    case "m": {
      const [type, port, protocol, fmt] = body.split(" ");
      return { type, port: Number(port), protocol, fmt: Number(fmt) };
    }
    default:
  }
};
var extractURIs = (buffer) => {
  const seekFrom = buffer.indexOf("\nm=");
  return extractLineVals(buffer, "a=control:", seekFrom);
};
var parse2 = (buffer) => {
  const sdp = buffer.toString("ascii").split("\n").map((s) => s.trim());
  const struct = { session: {}, media: [] };
  let mediaCounter = 0;
  let current = struct.session;
  for (const line of sdp) {
    if (newMediaLevel(line)) {
      struct.media[mediaCounter] = {};
      current = struct.media[mediaCounter];
      ++mediaCounter;
    }
    current = Object.assign(current, extractField(line));
  }
  return struct;
};
var messageFromBuffer = (buffer) => {
  return {
    type: 5 /* SDP */,
    data: buffer,
    sdp: parse2(buffer)
  };
};

// src/components/rtsp-parser/parser.ts
var INTERLEAVED_HEADER_BYTES = 4;
var ASCII_DOLLAR = 36;
var rtpPacketInfo = (chunks) => {
  const header = Buffer.alloc(INTERLEAVED_HEADER_BYTES);
  let i = 0;
  let bytesRead = 0;
  while (bytesRead < header.length) {
    const chunk = chunks[i++];
    const bytesToRead = Math.min(chunk.length, header.length - bytesRead);
    chunk.copy(header, bytesRead, 0, bytesToRead);
    bytesRead += bytesToRead;
  }
  const channel = header[1];
  const begin = header.length;
  const length = header.readUInt16BE(2);
  const end = begin + length;
  return { channel, begin, end };
};
var Parser = class {
  /**
   * Create a new Parser object.
   * @return {undefined}
   */
  constructor() {
    __publicField(this, "_chunks", []);
    __publicField(this, "_length", 0);
    __publicField(this, "_state", 0 /* IDLE */);
    __publicField(this, "_packet");
    this._init();
  }
  /**
   * Initialize the internal properties to their default starting
   * values.
   * @return {undefined}
   */
  _init() {
    this._chunks = [];
    this._length = 0;
    this._state = 0 /* IDLE */;
  }
  _push(chunk) {
    this._chunks.push(chunk);
    this._length += chunk.length;
  }
  /**
   * Extract RTSP messages.
   * @return {Array} An array of messages, possibly empty.
   */
  _parseRtsp() {
    const messages = [];
    const buffer = Buffer.concat(this._chunks);
    const chunkBodyOffset = bodyOffset(buffer);
    if (chunkBodyOffset === -1) {
      return messages;
    }
    const rtspHeaderLength = chunkBodyOffset;
    const contentLength = extractHeaderValue(buffer, "Content-Length");
    if (contentLength && parseInt(contentLength) > buffer.length - rtspHeaderLength) {
      return messages;
    }
    this._init();
    if (rtspHeaderLength === buffer.length || buffer[rtspHeaderLength] === ASCII_DOLLAR) {
      const packet = buffer.slice(0, rtspHeaderLength);
      messages.push({ type: 4 /* RTSP */, data: packet });
      const trailing = buffer.slice(rtspHeaderLength);
      this._push(trailing);
    } else {
      const packet = buffer;
      const body = buffer.slice(rtspHeaderLength);
      messages.push({ type: 4 /* RTSP */, data: packet });
      messages.push(messageFromBuffer(body));
    }
    return messages;
  }
  /**
   * Extract RTP/RTCP messages.
   * @return {Array} An array of messages, possibly empty.
   */
  _parseInterleaved() {
    const messages = [];
    if (this._length < INTERLEAVED_HEADER_BYTES) {
      return messages;
    }
    if (!this._packet) {
      this._packet = rtpPacketInfo(this._chunks);
    }
    if (this._length < this._packet.end) {
      return messages;
    }
    const buffer = Buffer.concat(this._chunks);
    const packet = buffer.slice(this._packet.begin, this._packet.end);
    const trailing = buffer.slice(this._packet.end);
    const channel = this._packet.channel;
    delete this._packet;
    this._init();
    this._push(trailing);
    if (channel % 2 === 0) {
      messages.push({ type: 2 /* RTP */, data: packet, channel });
    } else {
      let rtcpPackets = packet;
      do {
        const rtcpByteSize = rtcpPackets.readUInt16BE(2) * 4 + 4;
        messages.push(
          rtcpMessageFromBuffer(channel, rtcpPackets.slice(0, rtcpByteSize))
        );
        rtcpPackets = rtcpPackets.slice(rtcpByteSize);
      } while (rtcpPackets.length > 0);
    }
    return messages;
  }
  /**
   * Set the internal state based on the type of the first chunk
   */
  _setState() {
    while (this._chunks.length > 0 && this._chunks[0].length === 0) {
      this._chunks.shift();
    }
    const firstChunk = this._chunks[0];
    if (this._chunks.length === 0) {
      this._state = 0 /* IDLE */;
    } else if (firstChunk[0] === ASCII_DOLLAR) {
      this._state = 1 /* INTERLEAVED */;
    } else if (firstChunk.toString("ascii", 0, 4) === "RTSP") {
      this._state = 2 /* RTSP */;
    } else {
      throw new Error(`Unknown chunk of length ${firstChunk.length}`);
    }
  }
  /**
   * Add the next chunk of data to the parser and extract messages.
   * If no message can be extracted, an empty array is returned, otherwise
   * an array of messages is returned.
   * @param  chunk - The next piece of data.
   * @return An array of messages, possibly empty.
   */
  parse(chunk) {
    this._push(chunk);
    if (this._state === 0 /* IDLE */) {
      this._setState();
    }
    let messages = [];
    let done = false;
    while (!done) {
      let extracted = [];
      switch (this._state) {
        case 0 /* IDLE */:
          break;
        case 1 /* INTERLEAVED */:
          extracted = this._parseInterleaved();
          break;
        case 2 /* RTSP */:
          extracted = this._parseRtsp();
          break;
        default:
          throw new Error("internal error: unknown state");
      }
      if (extracted.length > 0) {
        messages = messages.concat(extracted);
      } else {
        done = true;
      }
      this._setState();
    }
    return messages;
  }
};

// src/components/rtsp-parser/index.ts
var RtspParser = class extends Tube {
  constructor() {
    const parser = new Parser();
    const incoming = new import_stream13.Transform({
      objectMode: true,
      transform(msg, encoding, callback) {
        if (msg.type === 1 /* RAW */) {
          try {
            parser.parse(msg.data).forEach((message) => incoming.push(message));
            callback();
          } catch (e) {
            const err = e;
            callback(err);
          }
        } else {
          callback(void 0, msg);
        }
      }
    });
    const outgoing = new import_stream13.Transform({
      objectMode: true,
      transform(msg, encoding, callback) {
        if (msg.type === 4 /* RTSP */) {
          const data = builder(msg);
          callback(void 0, { type: 1 /* RAW */, data });
        } else {
          callback(void 0, msg);
        }
      }
    });
    super(incoming, outgoing);
  }
};

// src/components/rtsp-session/index.ts
init_polyfill();
var import_debug7 = __toESM(require("debug"));
var import_stream14 = __toESM(require_stream_browserify());

// src/utils/config.ts
init_polyfill();
var merge = (template, override) => {
  let cleanOverride;
  if (override !== void 0) {
    if (typeof override !== "object") {
      throw new Error("merge expects override to be an object!");
    } else {
      cleanOverride = Object.keys(override).reduce(
        (acc, key) => {
          if (override[key] !== void 0) {
            acc[key] = override[key];
          }
          return acc;
        },
        {}
      );
    }
  }
  return Object.assign({}, template, cleanOverride);
};

// src/utils/protocols/ntp.ts
init_polyfill();
var NTP_UNIX_EPOCH_OFFSET = Date.UTC(1900, 0, 1);
function getTime(ntpMost, ntpLeast) {
  const ntpMilliSeconds = (ntpMost + ntpLeast / 4294967296) * 1e3;
  return NTP_UNIX_EPOCH_OFFSET + ntpMilliSeconds;
}

// src/components/rtsp-session/index.ts
function isAbsolute(url) {
  return /^[^:]+:\/\//.test(url);
}
var RTSP_METHOD = /* @__PURE__ */ ((RTSP_METHOD2) => {
  RTSP_METHOD2["OPTIONS"] = "OPTIONS";
  RTSP_METHOD2["DESCRIBE"] = "DESCRIBE";
  RTSP_METHOD2["SETUP"] = "SETUP";
  RTSP_METHOD2["PLAY"] = "PLAY";
  RTSP_METHOD2["PAUSE"] = "PAUSE";
  RTSP_METHOD2["TEARDOWN"] = "TEARDOWN";
  return RTSP_METHOD2;
})(RTSP_METHOD || {});
var MIN_SESSION_TIMEOUT = 5;
var defaultConfig = (hostname = typeof window === "undefined" ? "" : window.location.hostname, parameters = []) => {
  const uri = parameters.length > 0 ? `rtsp://${hostname}/axis-media/media.amp?${parameters.join("&")}` : `rtsp://${hostname}/axis-media/media.amp`;
  return { uri };
};
var RTSPResponseError = class extends Error {
  constructor(message, code) {
    super(message);
    __publicField(this, "code");
    this.name = "RTSPResponseError";
    this.code = code;
  }
};
var RtspSession = class extends Tube {
  /**
   * Create a new RTSP session controller component.
   * @param  [config] Details about the session.
   * @param  [config.hostname] The RTSP server hostname
   * @param  [config.parameters] The RTSP URI parameters
   * @param  [config.uri] The full RTSP URI (overrides any hostname/parameters)
   * @param  [config.defaultHeaders] Default headers to use (for all methods).
   * @param  [config.headers] Headers to use (mapped to each method).
   */
  constructor(config = {}) {
    const { uri, headers, defaultHeaders } = merge(
      defaultConfig(config.hostname, config.parameters),
      config
    );
    const incoming = new import_stream14.Transform({
      objectMode: true,
      transform: (msg, _, callback) => {
        if (msg.type === 4 /* RTSP */) {
          this._onRtsp(msg);
          callback();
        } else if (msg.type === 3 /* RTCP */) {
          this._onRtcp(msg);
          this.onRtcp && this.onRtcp(msg.rtcp);
          callback(void 0, msg);
        } else if (msg.type === 2 /* RTP */) {
          this._onRtp(msg);
          callback(void 0, msg);
        } else if (msg.type === 5 /* SDP */) {
          this._onSdp(msg);
          this.onSdp && this.onSdp(msg.sdp);
          callback(void 0, msg);
        } else {
          callback(void 0, msg);
        }
      }
    });
    incoming.on("end", () => {
      this._outgoingClosed = true;
    });
    super(incoming);
    __publicField(this, "uri");
    __publicField(this, "headers");
    __publicField(this, "defaultHeaders");
    __publicField(this, "t0");
    __publicField(this, "n0");
    __publicField(this, "clockrates");
    __publicField(this, "startTime");
    __publicField(this, "onRtcp");
    __publicField(this, "onSdp");
    __publicField(this, "onError");
    __publicField(this, "onPlay");
    __publicField(this, "retry");
    __publicField(this, "_outgoingClosed");
    __publicField(this, "_sequence");
    __publicField(this, "_callStack");
    __publicField(this, "_callHistory");
    __publicField(this, "_state");
    __publicField(this, "_waiting");
    __publicField(this, "_contentBase");
    __publicField(this, "_contentLocation");
    __publicField(this, "_sessionId");
    __publicField(this, "_sessionControlURL");
    __publicField(this, "_renewSessionInterval");
    this._outgoingClosed = false;
    this._reset();
    this.update(uri, headers, defaultHeaders);
    this._sessionControlURL = this._controlURL();
  }
  /**
   * Update the cached RTSP uri and headers.
   * @param  uri - The RTSP URI.
   * @param  headers - Maps commands to headers.
   * @param  defaultHeaders - Default headers.
   */
  update(uri, headers = {}, defaultHeaders = {}) {
    if (uri === void 0) {
      throw new Error(
        "You must supply an uri when creating a RtspSessionComponent"
      );
    }
    this.uri = uri;
    this.defaultHeaders = defaultHeaders;
    this.headers = Object.assign(
      {
        ["OPTIONS" /* OPTIONS */]: {},
        ["PLAY" /* PLAY */]: {},
        ["SETUP" /* SETUP */]: { Blocksize: "64000" },
        ["DESCRIBE" /* DESCRIBE */]: { Accept: "application/sdp" },
        ["PAUSE" /* PAUSE */]: {}
      },
      headers
    );
  }
  /**
   * Restore the initial values to the state they were in before any RTSP
   * connection was made.
   */
  _reset() {
    this._sequence = 1;
    this.retry = () => console.error("No request sent, can't retry");
    this._callStack = [];
    this._callHistory = [];
    this._state = "idle" /* IDLE */;
    this._waiting = false;
    this._contentBase = null;
    this._sessionId = null;
    if (this._renewSessionInterval !== null) {
      clearInterval(this._renewSessionInterval);
    }
    this._renewSessionInterval = null;
    this.t0 = void 0;
    this.n0 = void 0;
    this.clockrates = void 0;
  }
  _controlURL(attribute) {
    var _a, _b;
    if (attribute !== void 0 && isAbsolute(attribute)) {
      return attribute;
    }
    const baseURL = (_b = (_a = this._contentBase) != null ? _a : this._contentLocation) != null ? _b : this.uri;
    if (baseURL === null || baseURL === void 0) {
      throw new Error(
        "relative or missing control attribute but no base URL available"
      );
    }
    if (attribute === void 0 || attribute === "*") {
      return baseURL;
    }
    return new URL(attribute, baseURL).href;
  }
  /**
   * Handles incoming RTSP messages and send the next command in the queue.
   * @param  msg - An incoming RTSP message.
   */
  _onRtsp(msg) {
    this._waiting = false;
    const status = statusCode(msg.data);
    const ended = connectionEnded(msg.data);
    const seq = sequence(msg.data);
    if (seq === null) {
      throw new Error("rtsp: expected sequence number");
    }
    if (this._callHistory === void 0) {
      throw new Error("rtsp: internal error");
    }
    const method = this._callHistory[seq - 1];
    (0, import_debug7.default)("msl:rtsp:incoming")(`${msg.data}`);
    if (!this._sessionId && !ended) {
      this._sessionId = sessionId(msg.data);
      const _sessionTimeout = sessionTimeout(msg.data);
      if (_sessionTimeout !== null) {
        if (this._renewSessionInterval !== null) {
          clearInterval(this._renewSessionInterval);
        }
        this._renewSessionInterval = setInterval(
          () => {
            this._enqueue({ method: "OPTIONS" /* OPTIONS */ });
            this._dequeue();
          },
          Math.max(MIN_SESSION_TIMEOUT, _sessionTimeout - 5) * 1e3
        );
      }
    }
    if (!this._contentBase) {
      this._contentBase = contentBase(msg.data);
    }
    if (!this._contentLocation) {
      this._contentLocation = contentLocation(msg.data);
    }
    if (status >= 400) {
      this.onError && this.onError(
        new RTSPResponseError(msg.data.toString("ascii"), status)
      );
    }
    if (method === "PLAY" /* PLAY */) {
      this.onPlay && this.onPlay(range(msg.data));
    }
    if (ended) {
      (0, import_debug7.default)("msl:rtsp:incoming")(
        `RTSP Session ${this._sessionId} ended with statusCode: ${status}`
      );
      this._sessionId = null;
    }
    this._dequeue();
  }
  _onRtcp(msg) {
    if (this.t0 === void 0 || this.n0 === void 0) {
      throw new Error("rtsp: internal error");
    }
    if (isRtcpSR(msg.rtcp)) {
      const rtpChannel = msg.channel - 1;
      this.t0[rtpChannel] = msg.rtcp.rtpTimestamp;
      this.n0[rtpChannel] = getTime(msg.rtcp.ntpMost, msg.rtcp.ntpLeast);
    }
  }
  _onRtp(msg) {
    if (this.t0 === void 0 || this.n0 === void 0 || this.clockrates === void 0) {
      throw new Error("rtsp: internal error");
    }
    const rtpChannel = msg.channel;
    const t0 = this.t0[rtpChannel];
    const n0 = this.n0[rtpChannel];
    if (typeof t0 !== "undefined" && typeof n0 !== "undefined") {
      const clockrate = this.clockrates[rtpChannel];
      const t = timestamp(msg.data);
      const dt = t - t0 | 0;
      msg.ntpTimestamp = dt / clockrate * 1e3 + n0;
    }
  }
  /**
   * Handles incoming SDP messages, reply with SETUP and optionally PLAY.
   * @param  msg - An incoming SDP message.
   */
  _onSdp(msg) {
    this.n0 = {};
    this.t0 = {};
    this.clockrates = {};
    this._sessionControlURL = this._controlURL(msg.sdp.session.control);
    msg.sdp.media.forEach((media, index) => {
      if (media.rtpmap === void 0) {
        return;
      }
      const { clockrate } = media.rtpmap;
      const rtp = index * 2;
      const rtcp = rtp + 1;
      const uri = media.control === void 0 ? this._sessionControlURL : this._controlURL(media.control);
      this._enqueue({
        method: "SETUP" /* SETUP */,
        headers: {
          Transport: `RTP/AVP/TCP;unicast;interleaved=${rtp}-${rtcp}`
        },
        uri
      });
      if (this.clockrates === void 0) {
        return;
      }
      this.clockrates[rtp] = clockrate;
    });
    if (this._state === "playing" /* PLAYING */) {
      this._enqueue({
        method: "PLAY" /* PLAY */,
        headers: {
          Range: `npt=${this.startTime || 0}-`
        },
        uri: this._sessionControlURL
      });
    }
    this._dequeue();
  }
  /**
   * Set up command queue in order to start playing, i.e. PLAY optionally
   * preceeded by OPTIONS/DESCRIBE commands. If not waiting, immediately
   * start sending.
   * @param  startTime - Time (seconds) at which to start playing
   */
  play(startTime = 0) {
    if (this._state === "idle" /* IDLE */) {
      this.startTime = Number(startTime) || 0;
      this._enqueue({ method: "OPTIONS" /* OPTIONS */ });
      this._enqueue({ method: "DESCRIBE" /* DESCRIBE */ });
    } else if (this._state === "paused" /* PAUSED */) {
      if (this._sessionId === null || this._sessionId === void 0) {
        throw new Error("rtsp: internal error");
      }
      this._enqueue({
        method: "PLAY" /* PLAY */,
        headers: {
          Session: this._sessionId
        },
        uri: this._sessionControlURL
      });
    }
    this._state = "playing" /* PLAYING */;
    this._dequeue();
  }
  /**
   * Queue a pause command, and send if not waiting.
   * @return {undefined}
   */
  pause() {
    this._enqueue({ method: "PAUSE" /* PAUSE */ });
    this._state = "paused" /* PAUSED */;
    this._dequeue();
  }
  /**
   * End the session if there is one, otherwise just cancel
   * any outstanding calls on the stack.
   * @return {undefined}
   */
  stop() {
    if (this._sessionId) {
      this._enqueue({ method: "TEARDOWN" /* TEARDOWN */ });
    } else {
      this._callStack = [];
    }
    this._state = "idle" /* IDLE */;
    if (this._renewSessionInterval !== null) {
      clearInterval(this._renewSessionInterval);
      this._renewSessionInterval = null;
    }
    this._dequeue();
  }
  /**
   * Pushes an RTSP request onto the outgoing stream.
   * @param  cmd - The details about the command to send.
   */
  send(cmd) {
    const { method, headers, uri } = cmd;
    if (method === void 0) {
      throw new Error("missing method when send request");
    }
    this._waiting = true;
    this.retry = this.send.bind(this, cmd);
    if (this._sequence === void 0 || this.headers === void 0 || this._callHistory === void 0) {
      throw new Error("rtsp: internal error");
    }
    const message = Object.assign(
      {
        type: 4 /* RTSP */,
        uri: uri || this._sessionControlURL,
        data: Buffer.alloc(0)
        // data is a mandatory field. Not used by session -> parser messages.
      },
      { method, headers },
      {
        headers: Object.assign(
          { CSeq: this._sequence++ },
          this.defaultHeaders,
          // default headers (for all methods)
          this.headers[method],
          // preset headers for this method
          headers
          // headers that came with the invokation
        )
      }
    );
    this._sessionId && (message.headers.Session = this._sessionId);
    this._callHistory.push(method);
    if (!this._outgoingClosed) {
      this.outgoing.push(message);
    } else {
      (0, import_debug7.default)("msl:rtsp:outgoing")(`Unable to send ${method}, connection closed`);
    }
  }
  /**
   * Push a command onto the call stack.
   * @param  cmd - The command to queue
   */
  _enqueue(cmd) {
    if (this._callStack === void 0) {
      throw new Error("rtsp: internal error");
    }
    this._callStack.push(cmd);
  }
  /**
   * If possible, send the next command on the call stack.
   */
  _dequeue() {
    if (this._callStack === void 0) {
      throw new Error("rtsp: internal error");
    }
    if (!this._waiting && this._callStack.length > 0) {
      const cmd = this._callStack.shift();
      if (cmd !== void 0) {
        this.send(cmd);
      }
    }
  }
};

// src/components/ws-source/index.ts
init_polyfill();
var import_debug8 = __toESM(require("debug"));
var import_stream15 = __toESM(require_stream_browserify());

// src/components/ws-source/openwebsocket.ts
init_polyfill();
var WEBSOCKET_TIMEOUT = 10007;
var defaultConfig2 = (host = window.location.host, scheme = window.location.protocol) => {
  const wsScheme = scheme === "https:" ? "wss:" : "ws:";
  return {
    uri: `${wsScheme}//${host}/rtsp-over-websocket`,
    tokenUri: `${scheme}//${host}/axis-cgi/rtspwssession.cgi`,
    protocol: "binary",
    timeout: WEBSOCKET_TIMEOUT
  };
};
var openWebSocket = (..._0) => __async(void 0, [..._0], function* (config = {}) {
  const { uri, tokenUri, protocol, timeout } = merge(
    defaultConfig2(config.host, config.scheme),
    config
  );
  if (uri === void 0) {
    throw new Error("ws: internal error");
  }
  return yield new Promise((resolve, reject) => {
    try {
      const ws = new WebSocket(uri, protocol);
      const countdown = setTimeout(() => {
        clearTimeout(countdown);
        if (ws.readyState === WebSocket.CONNECTING) {
          ws.onerror = null;
          reject(new Error("websocket connection timed out"));
        }
      }, timeout);
      ws.binaryType = "arraybuffer";
      ws.onerror = (originalError) => {
        clearTimeout(countdown);
        function onLoadToken() {
          if (this.status >= 400) {
            console.warn("failed to load token", this.status, this.responseText);
            reject(originalError);
            return;
          }
          const token = this.responseText.trim();
          const newUri = `${uri}?rtspwssession=${token}`;
          const ws2 = new WebSocket(newUri, protocol);
          ws2.binaryType = "arraybuffer";
          ws2.onerror = (err) => {
            reject(err);
          };
          ws2.onopen = () => resolve(ws2);
        }
        const request = new XMLHttpRequest();
        request.addEventListener("load", onLoadToken);
        request.addEventListener("error", (err) => {
          console.warn("failed to get token");
          reject(err);
        });
        request.addEventListener("abort", () => reject(originalError));
        request.open("GET", `${tokenUri}?${Date.now()}`);
        try {
          request.send();
        } catch (error) {
          reject(originalError);
        }
      };
      ws.onopen = () => {
        clearTimeout(countdown);
        resolve(ws);
      };
    } catch (e) {
      reject(e);
    }
  });
});

// src/components/ws-source/index.ts
var CLOSE_GOING_AWAY = 1001;
var WSSource = class _WSSource extends Source {
  /**
   * Create a WebSocket component.
   *
   * The constructor sets up two streams and connects them to the socket as
   * soon as the socket is available (and open).
   *
   * @param socket - an open WebSocket.
   */
  constructor(socket) {
    if (socket === void 0) {
      throw new Error("socket argument missing");
    }
    const incoming = new import_stream15.Readable({
      objectMode: true,
      read() {
      }
    });
    socket.onmessage = (msg) => {
      const buffer = Buffer.from(msg.data);
      if (!incoming.push({ data: buffer, type: 1 /* RAW */ })) {
        if (socket.readyState === WebSocket.OPEN) {
          (0, import_debug8.default)("msl:websocket:incoming")("downstream frozen");
          socket.close();
        }
      }
    };
    incoming.on("error", (e) => {
      console.warn("closing socket due to incoming error", e);
      socket.close();
    });
    const outgoing = new import_stream15.Writable({
      objectMode: true,
      write(msg, encoding, callback) {
        try {
          socket.send(msg.data);
        } catch (e) {
          console.warn("message lost during send:", msg);
        }
        callback();
      }
    });
    outgoing.on("error", (e) => {
      console.warn("error during websocket send, ignoring:", e);
    });
    outgoing.on("finish", () => {
      (0, import_debug8.default)("msl:websocket:outgoing")("finish");
      if (socket.readyState !== WebSocket.CLOSED) {
        socket.close();
      }
    });
    socket.onclose = (e) => {
      (0, import_debug8.default)("msl:websocket:close")(`${e.code}`);
      if (e.code === CLOSE_GOING_AWAY) {
        this.onServerClose && this.onServerClose();
      }
      incoming.push(null);
      outgoing.end();
    };
    super(incoming, outgoing);
    __publicField(this, "onServerClose");
  }
  /**
   * Expose websocket opener as a class method that returns a promise which
   * resolves with a new WebSocketComponent.
   */
  static open(config) {
    return __async(this, null, function* () {
      return yield openWebSocket(config).then((socket) => new _WSSource(socket));
    });
  }
};

// src/pipelines/index.browser.ts
var index_browser_exports2 = {};
__export(index_browser_exports2, {
  Html5CanvasPipeline: () => Html5CanvasPipeline,
  Html5VideoMetadataPipeline: () => Html5VideoMetadataPipeline,
  Html5VideoPipeline: () => Html5VideoPipeline,
  HttpMsePipeline: () => HttpMsePipeline,
  MetadataPipeline: () => MetadataPipeline,
  Pipeline: () => Pipeline,
  RtspMjpegPipeline: () => RtspMjpegPipeline,
  RtspMp4Pipeline: () => RtspMp4Pipeline,
  RtspPipeline: () => RtspPipeline,
  WsSdpPipeline: () => WsSdpPipeline
});
init_polyfill();

// src/pipelines/pipeline.ts
init_polyfill();
var Pipeline = class {
  /**
   * @param components - The components of the pipeline in order.
   */
  constructor(...components) {
    __publicField(this, "firstComponent");
    __publicField(this, "lastComponent");
    __publicField(this, "_set");
    const [car, ...cdr] = components;
    this._set = new Set(components);
    this.firstComponent = car;
    this.lastComponent = cdr.reduce((last, component) => {
      return last.connect(component);
    }, car);
  }
  /**
   * @param components - The components of the pipeline in order.
   */
  init(...components) {
    const [car, ...cdr] = components;
    this._set = new Set(components);
    this.firstComponent = car;
    this.lastComponent = cdr.reduce((last, component) => {
      return last.connect(component);
    }, car);
  }
  /**
   * Inserts a component into the pipeline.
   *
   * @param component - Tube or Source behind which to insert a new component.
   * @param component - Tube or Sink to insert.
   */
  insertAfter(component, newComponent) {
    if (!this._set.has(component)) {
      throw new Error("insertion point not part of pipeline");
    }
    if (this._set.has(newComponent)) {
      throw new Error("new component already in the pipeline");
    }
    const cdr = component.next;
    if (cdr === null) {
      component.connect(newComponent);
      this.lastComponent = newComponent;
    } else {
      component.disconnect();
      component.connect(newComponent).connect(cdr);
    }
    this._set.add(newComponent);
    return this;
  }
  /**
   * Inserts a component into the pipeline.
   *
   * @param component - Tube or Sink in front of which to insert a new component.
   * @param component - Tube or Source to insert.
   */
  insertBefore(component, newComponent) {
    if (!this._set.has(component)) {
      throw new Error("insertion point not part of pipeline");
    }
    if (this._set.has(newComponent)) {
      throw new Error("new component already in the pipeline");
    }
    const car = component.prev;
    if (car === null) {
      newComponent.connect(component);
      this.firstComponent = newComponent;
    } else {
      car.disconnect();
      car.connect(newComponent).connect(component);
    }
    this._set.add(newComponent);
    return this;
  }
  /**
   * Removes a component from the pipeline.
   *
   * @param component - Component to remove.
   */
  remove(component) {
    if (!this._set.has(component)) {
      throw new Error("component not part of pipeline");
    }
    const car = component.prev;
    const cdr = component.next;
    if (car === null && cdr === null) {
      throw new Error("cannot remove last component");
    } else if (car === null && cdr !== null) {
      component.disconnect();
      this.firstComponent = cdr;
    } else if (car !== null && cdr === null) {
      car.disconnect();
      this.lastComponent = car;
    } else if (car !== null && cdr !== null) {
      car.disconnect();
      const cmp = component;
      cmp.disconnect();
      car.connect(cdr);
    }
    this._set.delete(component);
    return this;
  }
  /**
   * Inserts a component at the end of the pipeline.
   *
   * @param component - Tube or Sink to insert.
   */
  append(...components) {
    components.forEach((component) => {
      this.insertAfter(this.lastComponent, component);
    });
    return this;
  }
  /**
   * Inserts a component at the beginning of the pipeline.
   *
   * @param component - Tube or Source to insert.
   */
  prepend(...components) {
    components.forEach((component) => {
      this.insertBefore(this.firstComponent, component);
    });
    return this;
  }
};

// src/pipelines/rtsp-mjpeg-pipeline.ts
init_polyfill();

// src/pipelines/rtsp-pipeline.ts
init_polyfill();
var RtspPipeline = class extends Pipeline {
  constructor(rtspConfig) {
    const rtspParser = new RtspParser();
    const rtspSession = new RtspSession(rtspConfig);
    rtspSession.onSdp = (sdp) => {
      this.onSdp && this.onSdp(sdp);
    };
    rtspSession.onPlay = (range2) => {
      this.onPlay && this.onPlay(range2);
    };
    super(rtspParser, rtspSession);
    __publicField(this, "onSdp");
    __publicField(this, "onPlay");
    __publicField(this, "rtsp");
    this.rtsp = rtspSession;
  }
};

// src/pipelines/rtsp-mjpeg-pipeline.ts
var RtspMjpegPipeline = class extends RtspPipeline {
  constructor(rtspConfig) {
    super(rtspConfig);
    const jpegDepay = new JPEGDepay();
    this.append(jpegDepay);
  }
};

// src/pipelines/rtsp-mp4-pipeline.ts
init_polyfill();
var RtspMp4Pipeline = class extends RtspPipeline {
  constructor(rtspConfig) {
    super(rtspConfig);
    __publicField(this, "onSync");
    __publicField(this, "_mp4Muxer");
    const h264Depay = new H264Depay();
    const aacDepay = new AACDepay();
    const mp4Muxer = new Mp4Muxer();
    mp4Muxer.onSync = (ntpPresentationTime) => {
      this.onSync && this.onSync(ntpPresentationTime);
    };
    this.append(h264Depay, aacDepay, mp4Muxer);
    this._mp4Muxer = mp4Muxer;
  }
  get bitrate() {
    return this._mp4Muxer.bitrate;
  }
  get framerate() {
    return this._mp4Muxer.framerate;
  }
};

// src/pipelines/html5-canvas-pipeline.ts
init_polyfill();

// src/components/auth/index.ts
init_polyfill();

// src/components/auth/digest.ts
init_polyfill();
var import_ts_md5 = require("ts-md5");
function md5Hash(s) {
  const hash = new import_ts_md5.Md5().appendStr(s).end();
  if (hash === void 0) {
    throw new Error("empty MD5 hash");
  }
  return hash.toString();
}
var DigestAuth = class {
  constructor(params, username, password) {
    __publicField(this, "realm");
    __publicField(this, "nonce");
    __publicField(this, "opaque");
    __publicField(this, "algorithm");
    __publicField(this, "qop");
    __publicField(this, "username");
    __publicField(this, "ha1Base");
    __publicField(this, "count");
    __publicField(this, "nc", () => {
      ;
      ++this.count;
      return this.count.toString(16).padStart(8, "0");
    });
    __publicField(this, "cnonce", () => {
      return new Array(4).fill(0).map(() => Math.floor(Math.random() * 256)).map((n) => n.toString(16)).join("");
    });
    __publicField(this, "ha1", (cnonce) => {
      let ha1 = this.ha1Base;
      if (this.algorithm === "md5-sess") {
        ha1 = md5Hash(`${ha1}:${this.nonce}:${cnonce}`);
      }
      return ha1;
    });
    __publicField(this, "ha2", (method, uri, body = "") => {
      let ha2 = md5Hash(`${method}:${uri}`);
      if (this.algorithm === "md5-sess") {
        const hbody = md5Hash(body);
        ha2 = md5Hash(`${method}:${uri}:${hbody}`);
      }
      return ha2;
    });
    __publicField(this, "authorization", (method = "GET", uri = "", body) => {
      const nc = this.nc();
      const cnonce = this.cnonce();
      const ha1 = this.ha1(cnonce);
      const ha2 = this.ha2(method, uri, body);
      const response = this.qop === void 0 ? md5Hash(`${ha1}:${this.nonce}:${ha2}`) : md5Hash(`${ha1}:${this.nonce}:${nc}:${cnonce}:${this.qop}:${ha2}`);
      const authorizationParams = [];
      authorizationParams.push(`username="${this.username}"`);
      authorizationParams.push(`realm="${this.realm}"`);
      authorizationParams.push(`nonce="${this.nonce}"`);
      authorizationParams.push(`uri="${uri}"`);
      if (this.qop !== void 0) {
        authorizationParams.push(`qop=${this.qop}`);
        authorizationParams.push(`nc=${nc}`);
        authorizationParams.push(`cnonce="${cnonce}"`);
      }
      authorizationParams.push(`response="${response}"`);
      if (this.opaque !== void 0) {
        authorizationParams.push(`opaque="${this.opaque}"`);
      }
      return `Digest ${authorizationParams.join(", ")}`;
    });
    const realm = params.get("realm");
    if (realm === void 0) {
      throw new Error("no realm in digest challenge");
    }
    this.realm = realm;
    this.ha1Base = md5Hash(`${username}:${realm}:${password}`);
    const nonce = params.get("nonce");
    if (nonce === void 0) {
      throw new Error("no nonce in digest challenge");
    }
    this.nonce = nonce;
    this.opaque = params.get("opaque");
    const algorithm = params.get("algorithm");
    if (algorithm !== void 0) {
      if (algorithm === "md5") {
        this.algorithm = "md5";
      } else if (algorithm === "md5-sess") {
        this.algorithm = "md5-sess";
      }
    } else {
      this.algorithm = "md5";
    }
    const qop = params.get("qop");
    if (qop !== void 0) {
      const possibleQops = qop.split(",").map((qopType) => qopType.trim());
      if (possibleQops.some((qopValue) => qopValue === "auth")) {
        this.qop = "auth";
      } else if (possibleQops.some((qopValue) => qopValue === "auth-int")) {
        this.qop = "auth-int";
      }
    }
    this.count = 0;
    this.username = username;
  }
};

// src/components/auth/www-authenticate.ts
init_polyfill();
var parseWWWAuthenticate = (header) => {
  const [, type, ...challenge] = header.split(" ");
  const pairs = [];
  const re = /\s*([^=]+)="([^"]*)",?/gm;
  let match;
  do {
    match = re.exec(challenge.join(" "));
    if (match !== null) {
      const [, key, value] = match;
      pairs.push([key, value]);
    }
  } while (match !== null);
  const params = new Map(pairs);
  return { type: type.toLowerCase(), params };
};

// src/components/auth/index.ts
var UNAUTHORIZED = 401;
var DEFAULT_CONFIG = {
  username: "root",
  password: "pass"
};
var Auth = class extends Tube {
  constructor(config = {}) {
    const { username, password } = merge(DEFAULT_CONFIG, config);
    if (username === void 0 || password === void 0) {
      throw new Error("need username and password");
    }
    let lastSentMessage;
    let authHeader;
    const outgoing = createTransform(function(msg, encoding, callback) {
      if (msg.type === 4 /* RTSP */) {
        lastSentMessage = msg;
        if (authHeader && msg.headers) {
          msg.headers.Authorization = authHeader;
        }
      }
      callback(void 0, msg);
    });
    const incoming = createTransform(function(msg, encoding, callback) {
      if (msg.type === 4 /* RTSP */ && statusCode(msg.data) === UNAUTHORIZED) {
        const headers = msg.data.toString().split("\n");
        const wwwAuth = headers.find((header) => /WWW-Auth/i.test(header));
        if (wwwAuth === void 0) {
          throw new Error("cannot find WWW-Authenticate header");
        }
        const challenge = parseWWWAuthenticate(wwwAuth);
        if (challenge.type === "basic") {
          authHeader = `Basic ${Buffer.from(`${username}:${password}`).toString(
            "base64"
          )}`;
        } else if (challenge.type === "digest") {
          const digest = new DigestAuth(challenge.params, username, password);
          authHeader = digest.authorization(
            lastSentMessage.method,
            lastSentMessage.uri
          );
        } else {
          return;
        }
        outgoing.write(lastSentMessage, () => callback());
      } else {
        callback(void 0, msg);
      }
    });
    super(incoming, outgoing);
  }
};

// src/pipelines/html5-canvas-pipeline.ts
var Html5CanvasPipeline = class extends RtspMjpegPipeline {
  constructor(config) {
    const {
      ws: wsConfig,
      rtsp: rtspConfig,
      mediaElement,
      auth: authConfig
    } = config;
    super(rtspConfig);
    __publicField(this, "onCanplay");
    __publicField(this, "onSync");
    __publicField(this, "onServerClose");
    __publicField(this, "ready");
    __publicField(this, "_src");
    __publicField(this, "_sink");
    if (authConfig) {
      const auth = new Auth(authConfig);
      this.insertBefore(this.rtsp, auth);
    }
    const canvasSink = new CanvasSink(mediaElement);
    canvasSink.onCanplay = () => {
      canvasSink.play();
      this.onCanplay && this.onCanplay();
    };
    canvasSink.onSync = (ntpPresentationTime) => {
      this.onSync && this.onSync(ntpPresentationTime);
    };
    this.append(canvasSink);
    this._sink = canvasSink;
    const waitForWs = WSSource.open(wsConfig);
    this.ready = waitForWs.then((wsSource) => {
      wsSource.onServerClose = () => {
        this.onServerClose && this.onServerClose();
      };
      this.prepend(wsSource);
      this._src = wsSource;
    });
  }
  close() {
    this.rtsp.stop();
    this._src && this._src.outgoing.end();
  }
  get currentTime() {
    return this._sink.currentTime;
  }
  play() {
    return this._sink.play();
  }
  pause() {
    return this._sink.pause();
  }
  get bitrate() {
    return this._sink.bitrate;
  }
  get framerate() {
    return this._sink.framerate;
  }
};

// src/pipelines/html5-video-metadata-pipeline.ts
init_polyfill();

// src/pipelines/html5-video-pipeline.ts
init_polyfill();
var Html5VideoPipeline = class extends RtspMp4Pipeline {
  constructor(config) {
    const {
      ws: wsConfig,
      rtsp: rtspConfig,
      mediaElement,
      auth: authConfig
    } = config;
    super(rtspConfig);
    __publicField(this, "onSourceOpen");
    __publicField(this, "onServerClose");
    __publicField(this, "ready");
    __publicField(this, "tracks");
    __publicField(this, "_src");
    __publicField(this, "_sink");
    if (authConfig) {
      const auth = new Auth(authConfig);
      this.insertBefore(this.rtsp, auth);
    }
    const mseSink = new MseSink(mediaElement);
    mseSink.onSourceOpen = (mse, tracks) => {
      this.tracks = tracks;
      this.onSourceOpen && this.onSourceOpen(mse, tracks);
    };
    this.append(mseSink);
    this._sink = mseSink;
    const waitForWs = WSSource.open(wsConfig);
    this.ready = waitForWs.then((wsSource) => {
      wsSource.onServerClose = () => {
        this.onServerClose && this.onServerClose();
      };
      this.prepend(wsSource);
      this._src = wsSource;
    });
  }
  close() {
    this.rtsp.stop();
    this._src && this._src.outgoing.end();
  }
  get currentTime() {
    return this._sink.currentTime;
  }
  play() {
    return __async(this, null, function* () {
      return yield this._sink.play();
    });
  }
  pause() {
    return this._sink.pause();
  }
};

// src/pipelines/html5-video-metadata-pipeline.ts
var Html5VideoMetadataPipeline = class extends Html5VideoPipeline {
  constructor(config) {
    const { metadataHandler } = config;
    super(config);
    const onvifDepay = new ONVIFDepay();
    this.insertAfter(this.rtsp, onvifDepay);
    const onvifHandlerPipe = Tube.fromHandlers((msg) => {
      if (msg.type === 9 /* XML */) {
        metadataHandler(msg);
      }
    }, void 0);
    this.insertAfter(onvifDepay, onvifHandlerPipe);
  }
};

// src/pipelines/metadata-pipeline.ts
init_polyfill();
var DEFAULT_RTSP_PARAMETERS = {
  parameters: ["audio=0", "video=0", "event=on", "ptz=all"]
};
var MetadataPipeline = class extends RtspPipeline {
  constructor(config) {
    const { ws: wsConfig, rtsp: rtspConfig, metadataHandler } = config;
    super(Object.assign({}, DEFAULT_RTSP_PARAMETERS, rtspConfig));
    __publicField(this, "onServerClose");
    __publicField(this, "ready");
    __publicField(this, "_src");
    const onvifDepay = new ONVIFDepay();
    this.append(onvifDepay);
    const handlerSink = Sink.fromHandler((msg) => {
      if (msg.type === 9 /* XML */) {
        metadataHandler(msg);
      }
    });
    this.append(handlerSink);
    const waitForWs = WSSource.open(wsConfig);
    this.ready = waitForWs.then((wsSource) => {
      wsSource.onServerClose = () => {
        this.onServerClose && this.onServerClose();
      };
      this.prepend(wsSource);
      this._src = wsSource;
    });
  }
  close() {
    this._src && this._src.outgoing.end();
  }
};

// src/pipelines/ws-sdp-pipeline.ts
init_polyfill();
var WsSdpPipeline = class extends RtspPipeline {
  constructor(config) {
    const { ws: wsConfig, rtsp: rtspConfig, auth: authConfig } = config;
    super(rtspConfig);
    __publicField(this, "onServerClose");
    __publicField(this, "ready");
    __publicField(this, "_src");
    if (authConfig) {
      const auth = new Auth(authConfig);
      this.insertBefore(this.rtsp, auth);
    }
    const waitForWs = WSSource.open(wsConfig);
    this.ready = waitForWs.then((wsSource) => {
      wsSource.onServerClose = () => {
        this.onServerClose && this.onServerClose();
      };
      this.prepend(wsSource);
      this._src = wsSource;
    });
  }
  close() {
    this._src && this._src.outgoing.end();
  }
  get sdp() {
    return this.ready.then(() => __async(this, null, function* () {
      const sdpPromise = new Promise((resolve) => {
        this.rtsp.onSdp = resolve;
      });
      this.rtsp.send({ method: "DESCRIBE" /* DESCRIBE */ });
      this.rtsp.send({ method: "TEARDOWN" /* TEARDOWN */ });
      return yield sdpPromise;
    }));
  }
};

// src/pipelines/http-mse-pipeline.ts
init_polyfill();

// src/components/http-mp4/index.ts
init_polyfill();
var import_debug9 = __toESM(require("debug"));
var import_stream16 = __toESM(require_stream_browserify());
var debug9 = (0, import_debug9.default)("msl:http-mp4");
var HttpMp4Source = class extends Source {
  /**
   * Create an HTTP component.
   *
   * The constructor sets a single readable stream from a fetch.
   */
  constructor(config) {
    const { uri, options } = config;
    const incoming = new import_stream16.Readable({
      objectMode: true,
      read() {
      }
    });
    incoming.on("error", (e) => {
      console.warn("closing socket due to incoming error", e);
      this._reader && this._reader.cancel().catch((err) => console.error(err));
    });
    super(incoming);
    __publicField(this, "uri");
    __publicField(this, "options");
    __publicField(this, "length");
    __publicField(this, "onHeaders");
    __publicField(this, "onServerClose");
    __publicField(this, "_reader");
    __publicField(this, "_abortController");
    __publicField(this, "_allDone");
    incoming._read = () => {
      this._pull();
    };
    this.uri = uri;
    this.options = options;
    this._allDone = false;
  }
  play() {
    if (this.uri === void 0) {
      throw new Error("cannot start playing when there is no URI");
    }
    this._abortController = new AbortController();
    this.length = 0;
    fetch(this.uri, __spreadValues({
      credentials: "include",
      signal: this._abortController.signal
    }, this.options)).then((rsp) => {
      if (rsp.body === null) {
        throw new Error("empty response body");
      }
      const contentType = rsp.headers.get("Content-Type");
      this.incoming.push({
        data: Buffer.alloc(0),
        type: 8 /* ISOM */,
        mime: contentType
      });
      this.onHeaders && this.onHeaders(rsp.headers);
      this._reader = rsp.body.getReader();
      this._pull();
    }).catch((err) => {
      console.error("http-source: fetch failed: ", err);
    });
  }
  abort() {
    this._reader && this._reader.cancel().catch((err) => {
      console.log("http-source: cancel reader failed: ", err);
    });
    this._abortController && this._abortController.abort();
  }
  _isClosed() {
    return this._allDone;
  }
  _close() {
    var _a;
    this._reader = void 0;
    this._allDone = true;
    this.incoming.push(null);
    (_a = this.onServerClose) == null ? void 0 : _a.call(this);
  }
  _pull() {
    if (this._reader === void 0) {
      return;
    }
    this._reader.read().then(({ done, value }) => {
      if (done) {
        if (!this._isClosed()) {
          debug9("fetch completed, total downloaded: ", this.length, " bytes");
          this._close();
        }
        return;
      }
      if (value === void 0) {
        throw new Error("expected value to be defined");
      }
      if (this.length === void 0) {
        throw new Error("expected length to be defined");
      }
      this.length += value.length;
      const buffer = Buffer.from(value);
      if (!this.incoming.push({ data: buffer, type: 8 /* ISOM */ })) {
        debug9("downstream back pressure: pausing read");
      } else {
        this._pull();
      }
    }).catch((err) => {
      debug9("http-source: read failed: ", err);
      if (!this._isClosed()) {
        this._close();
      }
    });
  }
};

// src/pipelines/http-mse-pipeline.ts
var HttpMsePipeline = class extends Pipeline {
  constructor(config) {
    const { http: httpConfig, mediaElement } = config;
    const httpSource = new HttpMp4Source(httpConfig);
    const mseSink = new MseSink(mediaElement);
    httpSource.onHeaders = (headers) => {
      this.onHeaders && this.onHeaders(headers);
    };
    httpSource.onServerClose = () => {
      var _a;
      return (_a = this.onServerClose) == null ? void 0 : _a.call(this);
    };
    super(httpSource, mseSink);
    __publicField(this, "onHeaders");
    __publicField(this, "onServerClose");
    __publicField(this, "http");
    __publicField(this, "_src");
    __publicField(this, "_sink");
    this._src = httpSource;
    this._sink = mseSink;
    this.http = httpSource;
  }
  close() {
    this._src && this._src.abort();
  }
  get currentTime() {
    return this._sink.currentTime;
  }
  play() {
    return __async(this, null, function* () {
      return yield this._sink.play();
    });
  }
  pause() {
    return this._sink.pause();
  }
};

// src/utils/index.browser.ts
var index_browser_exports3 = {};
__export(index_browser_exports3, {
  RTCPPacketType: () => RTCPPacketType,
  SDESItem: () => SDESItem,
  SR: () => SR,
  Scheduler: () => Scheduler,
  addRTSPRetry: () => addRTSPRetry,
  bodyOffset: () => bodyOffset,
  cSrc: () => cSrc,
  cSrcCount: () => cSrcCount,
  connectionEnded: () => connectionEnded,
  contentBase: () => contentBase,
  contentLocation: () => contentLocation,
  extHeader: () => extHeader,
  extHeaderLength: () => extHeaderLength,
  extension: () => extension,
  extractHeaderValue: () => extractHeaderValue,
  extractURIs: () => extractURIs,
  getTime: () => getTime,
  isRtcpApp: () => isRtcpApp,
  isRtcpBye: () => isRtcpBye,
  isRtcpRR: () => isRtcpRR,
  isRtcpSDES: () => isRtcpSDES,
  isRtcpSR: () => isRtcpSR,
  marker: () => marker,
  messageFromBuffer: () => messageFromBuffer,
  padding: () => padding,
  parse: () => parse2,
  parseRtcp: () => parseRtcp,
  payload: () => payload,
  payloadType: () => payloadType,
  range: () => range,
  rtcpMessageFromBuffer: () => rtcpMessageFromBuffer,
  sSrc: () => sSrc,
  sequence: () => sequence,
  sequenceNumber: () => sequenceNumber,
  sessionId: () => sessionId,
  sessionTimeout: () => sessionTimeout,
  statusCode: () => statusCode,
  timestamp: () => timestamp,
  version: () => version
});
init_polyfill();

// src/utils/protocols/index.ts
init_polyfill();

// src/utils/retry.ts
init_polyfill();
var addRTSPRetry = (rtspSession, { maxRetries, errors } = { maxRetries: 20, errors: [503] }) => {
  let retries = 0;
  const oldOnError = rtspSession.onError;
  rtspSession.onError = (err) => {
    oldOnError == null ? void 0 : oldOnError(err);
    if (!errors.includes(err.code)) {
      return;
    }
    if ((retries += 1) > maxRetries) {
      console.log("retry, too many", retries, maxRetries);
      return;
    }
    setTimeout(() => {
      var _a;
      return (_a = rtspSession.retry) == null ? void 0 : _a.call(rtspSession);
    }, retries * 100);
  };
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=browser-cjs.js.map
