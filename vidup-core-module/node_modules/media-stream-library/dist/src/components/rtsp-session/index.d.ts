import { Rtcp } from '../../utils/protocols/rtcp';
import { Sdp } from '../../utils/protocols/sdp';
import { Tube } from '../component';
import { RtcpMessage, RtpMessage, RtspMessage, SdpMessage } from '../message';
export declare enum RTSP_METHOD {
    OPTIONS = "OPTIONS",
    DESCRIBE = "DESCRIBE",
    SETUP = "SETUP",
    PLAY = "PLAY",
    PAUSE = "PAUSE",
    TEARDOWN = "TEARDOWN"
}
interface Headers {
    [key: string]: string;
}
interface Command {
    method: RTSP_METHOD;
    headers?: Headers;
    uri?: string;
}
interface MethodHeaders {
    [key: string]: Headers;
}
export interface RtspConfig {
    hostname?: string;
    parameters?: string[];
    uri?: string;
    headers?: MethodHeaders;
    defaultHeaders?: Headers;
}
export declare class RTSPResponseError extends Error {
    code: number;
    constructor(message: string, code: number);
}
/**
 * A component that sets up a command queue in order to interact with the RTSP
 * server. Allows control over the RTSP session by listening to incoming messages
 * and sending request on the outgoing stream.
 *
 * The following handlers can be set on the component:
 *  - onSdp: will be called when an SDP object is sent with the object as argument
 *  - onPlay: will be called when an RTSP PLAY response is sent with the media range
 *            as argument. The latter is an array [start, stop], where start is "now"
 *            (for live) or a time in seconds, and stop is undefined (for live or
 *            ongoing streams) or a time in seconds.
 * @extends {Component}
 */
export declare class RtspSession extends Tube {
    uri?: string;
    headers?: MethodHeaders;
    defaultHeaders?: Headers;
    t0?: {
        [key: number]: number;
    };
    n0?: {
        [key: number]: number;
    };
    clockrates?: {
        [key: number]: number;
    };
    startTime?: number;
    onRtcp?: (rtcp: Rtcp) => void;
    onSdp?: (sdp: Sdp) => void;
    onError?: (err: RTSPResponseError) => void;
    onPlay?: (range?: string[]) => void;
    retry?: () => void;
    private _outgoingClosed;
    private _sequence?;
    private _callStack?;
    private _callHistory?;
    private _state?;
    private _waiting?;
    private _contentBase?;
    private _contentLocation?;
    private _sessionId?;
    private _sessionControlURL;
    private _renewSessionInterval?;
    /**
     * Create a new RTSP session controller component.
     * @param  [config] Details about the session.
     * @param  [config.hostname] The RTSP server hostname
     * @param  [config.parameters] The RTSP URI parameters
     * @param  [config.uri] The full RTSP URI (overrides any hostname/parameters)
     * @param  [config.defaultHeaders] Default headers to use (for all methods).
     * @param  [config.headers] Headers to use (mapped to each method).
     */
    constructor(config?: RtspConfig);
    /**
     * Update the cached RTSP uri and headers.
     * @param  uri - The RTSP URI.
     * @param  headers - Maps commands to headers.
     * @param  defaultHeaders - Default headers.
     */
    update(uri: string | undefined, headers?: MethodHeaders, defaultHeaders?: Headers): void;
    /**
     * Restore the initial values to the state they were in before any RTSP
     * connection was made.
     */
    _reset(): void;
    _controlURL(attribute?: string): string;
    /**
     * Handles incoming RTSP messages and send the next command in the queue.
     * @param  msg - An incoming RTSP message.
     */
    _onRtsp(msg: RtspMessage): void;
    _onRtcp(msg: RtcpMessage): void;
    _onRtp(msg: RtpMessage): void;
    /**
     * Handles incoming SDP messages, reply with SETUP and optionally PLAY.
     * @param  msg - An incoming SDP message.
     */
    _onSdp(msg: SdpMessage): void;
    /**
     * Set up command queue in order to start playing, i.e. PLAY optionally
     * preceeded by OPTIONS/DESCRIBE commands. If not waiting, immediately
     * start sending.
     * @param  startTime - Time (seconds) at which to start playing
     */
    play(startTime?: number): void;
    /**
     * Queue a pause command, and send if not waiting.
     * @return {undefined}
     */
    pause(): void;
    /**
     * End the session if there is one, otherwise just cancel
     * any outstanding calls on the stack.
     * @return {undefined}
     */
    stop(): void;
    /**
     * Pushes an RTSP request onto the outgoing stream.
     * @param  cmd - The details about the command to send.
     */
    send(cmd: Command): void;
    /**
     * Push a command onto the call stack.
     * @param  cmd - The command to queue
     */
    _enqueue(cmd: Command): void;
    /**
     * If possible, send the next command on the call stack.
     */
    _dequeue(): void;
}
export {};
